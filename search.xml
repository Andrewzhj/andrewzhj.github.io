<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jvm-concept</title>
    <url>/2020/08/28/java/jvm/jvm-concept/</url>
    <content><![CDATA[<p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a><br><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works</a><br><a href="http://www.oracle.com/technetwork/java/javase/tech/exactoptions-jsp-141536.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/exactoptions-jsp-141536.html</a><br><a href="https://javapapers.com/java/java-garbage-collection-introduction" target="_blank" rel="noopener">https://javapapers.com/java/java-garbage-collection-introduction</a><br><a href="https://javapapers.com/java/how-java-garbage-collection-works" target="_blank" rel="noopener">https://javapapers.com/java/how-java-garbage-collection-works</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html</a><br><a href="https://docs.oracle.com/javase/10/gctuning/factors-affecting-garbage-collection-performance.htm" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/gctuning/factors-affecting-garbage-collection-performance.htm</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html</a><br><a href="https://javainterviewpoint.com/category/java/" target="_blank" rel="noopener">https://javainterviewpoint.com/category/java/</a><br><a href="https://www.cnblogs.com/liululee/archive/2019/09/04/11461998.html" target="_blank" rel="noopener">https://www.cnblogs.com/liululee/archive/2019/09/04/11461998.html</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html</a><br><a href="https://docs.oracle.com/javase/10/gctuning/toc.htm" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/gctuning/toc.htm</a><br><a href="https://blog.csdn.net/laomo_bible/article/details/83112622" target="_blank" rel="noopener">https://blog.csdn.net/laomo_bible/article/details/83112622</a></p>
]]></content>
  </entry>
  <entry>
    <title>flink-sql</title>
    <url>/2020/08/28/flink/tutorial/flink-sql/</url>
    <content><![CDATA[<p><a href="https://github.com/wuchong/flink-sql-demo" target="_blank" rel="noopener">https://github.com/wuchong/flink-sql-demo</a></p>
]]></content>
  </entry>
  <entry>
    <title>flink-docker</title>
    <url>/2020/08/28/flink/tutorial/flink-docker/</url>
    <content><![CDATA[<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><font color="#009100">参考文档</font></tr></table></h1><p><a href="https://hub.docker.com/_/flink" target="_blank" rel="noopener">https://hub.docker.com/_/flink</a><br><a href="https://blog.csdn.net/godelgnis/article/details/104528408" target="_blank" rel="noopener">https://blog.csdn.net/godelgnis/article/details/104528408</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>flink</title>
    <url>/2020/08/28/faq/flink/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><table><tr><font color="#009100">概念</font></tr></table></h1><p>1.阐述 Flink 如何处理反压，相比 Storm，Spark  Streaming 提供的反压机制，描述其实现有什么不同？</p>
<p>2.阐述流处理引擎提供的三种数据处理语义，解释 Flink  Checkpoint 机制如何保证 Flink 程序结果的 Exactly-Once 语义，描述如何通过两阶段提交协议提供端到端的 Exactly-Once 保证？结合 Kafka 如何构建端到端的 Exactly-Once 处理？</p>
<p>3.阐述 Flink 提供的容错机制，解释分布式快照 Chandy  Lamport 算法逻辑，剖析 Flink  Checkpoint 具体实现流程？</p>
<p>4.如何处理 Flink 作业频繁重启问题？</p>
<p>5.如何优化大状态的 Flink 作业？</p>
<p>6.如何排查 Flink Checkpoint 超时问题？</p>
<p>7.如何处理 Flink 作业中的数据倾斜问题？</p>
<p>8.Flink 反压机制，如何排查反压瓶颈在哪，及如何处理反压问题？</p>
<p>9.哪种 join 可以满足单个流断流的时候仍然能够保证正确的 join 到数据？</p>
<p>10.watermark 是怎么生成和传递的？</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><font color="#009100">参考文档</font></tr></table></h1><p><a href="https://mp.weixin.qq.com/s/Nf4iV_sNitOMQkw7PGgvOQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nf4iV_sNitOMQkw7PGgvOQ</a><br><a href="https://ververica.cn/developers/special-issue/" target="_blank" rel="noopener">https://ververica.cn/developers/special-issue/</a><br><a href="https://files.alicdn.com/tpsservice/aeec17aa6ab8d7d03bff2a1f7463f528.pdf" target="_blank" rel="noopener">https://files.alicdn.com/tpsservice/aeec17aa6ab8d7d03bff2a1f7463f528.pdf</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>faq</tag>
      </tags>
  </entry>
  <entry>
    <title>flink-exactly-once</title>
    <url>/2020/08/28/flink/tutorial/flink-exactly-once/</url>
    <content><![CDATA[<h1 id="1-运行kafka"><a href="#1-运行kafka" class="headerlink" title="1.运行kafka"></a><table><tr><font color="#009100">1.运行kafka</font></tr></table></h1><p>选择 wurstmeister/zookeeper、wurstmeister/kafka 两个镜像快速启动kafka。</p>
<h2 id="1-1-docker运行kafka"><a href="#1-1-docker运行kafka" class="headerlink" title="1.1 docker运行kafka"></a>1.1 docker运行kafka</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name zookeeper -p 2181:2181 -t wurstmeister/zookeeper</span><br><span class="line"></span><br><span class="line">ip=`ifconfig en0 | sed -n '/inet/p'| sed -n '/netmask/p' | awk -F' ' '&#123;print $2&#125;'`</span><br><span class="line">docker run  -d --name kafka \</span><br><span class="line">    -p 9092:9092 \</span><br><span class="line">    -e KAFKA_BROKER_ID=0 \</span><br><span class="line">    -e KAFKA_ZOOKEEPER_CONNECT=$ip:2181 \</span><br><span class="line">    -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://$ip:9092 \</span><br><span class="line">    -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br><span class="line"></span><br><span class="line">docker run  -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=192.168.1.2:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.1.2:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br></pre></td></tr></table></figure>

</details>

<h2 id="1-2-创建kafka主题"><a href="#1-2-创建kafka主题" class="headerlink" title="1.2 创建kafka主题"></a>1.2 创建kafka主题</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper 192.168.1.2:2181 --replication-factor 1 --partitions 1 --topic topic-input</span><br><span class="line"></span><br><span class="line">bin/kafka-topics.sh --create --zookeeper 192.168.1.2:2181 --replication-factor 1 --partitions 1 --topic topic-output</span><br></pre></td></tr></table></figure>
</details>

<h1 id="2-flink-kafka-使用"><a href="#2-flink-kafka-使用" class="headerlink" title="2.flink kafka 使用"></a><table><tr><font color="#009100">2.flink kafka 使用</font></tr></table></h1><h2 id="fink-kafka-版本依赖"><a href="#fink-kafka-版本依赖" class="headerlink" title="fink kafka 版本依赖"></a>fink kafka 版本依赖</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;flink.version&gt;1.11.1&lt;/flink.version&gt;</span><br><span class="line">    &lt;scala.version&gt;2.11&lt;/scala.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-connector-kafka_$&#123;scala.version&#125;&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</details>


<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><font color="#009100">参考文档</font></tr></table></h1><p><a href="https://flink.apache.org/features/2018/03/01/end-to-end-exactly-once-apache-flink.html" target="_blank" rel="noopener">https://flink.apache.org/features/2018/03/01/end-to-end-exactly-once-apache-flink.html</a><br><a href="https://ververica.cn/developers/anatomy-of-flink-kafka-connector-and-exactly-once/" target="_blank" rel="noopener">https://ververica.cn/developers/anatomy-of-flink-kafka-connector-and-exactly-once/</a><br><a href="https://ververica.cn/developers/flink-kafka-end-to-end-exactly-once-analysis/" target="_blank" rel="noopener">https://ververica.cn/developers/flink-kafka-end-to-end-exactly-once-analysis/</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/kafka.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/kafka.html</a><br><a href="https://blog.csdn.net/lblblblblzdx/article/details/80548294" target="_blank" rel="noopener">https://blog.csdn.net/lblblblblzdx/article/details/80548294</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>exactly-once</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch Sink 源码</title>
    <url>/2020/08/10/flink/coding/essink/</url>
    <content><![CDATA[<h1 id="Maven-引用"><a href="#Maven-引用" class="headerlink" title="Maven 引用"></a><table><tr><font color="#009100">Maven 引用</font></tr></table></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch5_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Java-调用方式"><a href="#Java-调用方式" class="headerlink" title="Java 调用方式"></a><table><tr><font color="#009100">Java 调用方式</font></tr></table></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;InetSocketAddress&gt; transportAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String clusterNodes = YmlReader.getValue(<span class="string">"es.cluster.nodes"</span>);</span><br><span class="line">        <span class="keyword">for</span>( String clusterNode : clusterNodes.split( <span class="string">","</span> )) &#123;</span><br><span class="line">            String hostName = clusterNode.substring( <span class="number">0</span>,clusterNode.indexOf( <span class="string">":"</span> ) );</span><br><span class="line">            String port = clusterNode.substring( clusterNode.indexOf( <span class="string">":"</span> )+<span class="number">1</span>, clusterNode.length());</span><br><span class="line">            log.info( <span class="string">"adding transport node : "</span> + clusterNode );</span><br><span class="line">            transportAddresses.add(<span class="keyword">new</span> InetSocketAddress( InetAddress.getByName(hostName), Integer.valueOf(port)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; userConfig;</span><br><span class="line">    userConfig = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">7</span>);</span><br><span class="line">    userConfig.put(<span class="string">"cluster.name"</span>, YmlReader.getValue(<span class="string">"es.cluster.name"</span>));</span><br><span class="line">    userConfig.put(<span class="string">"bulk.flush.max.actions"</span>, <span class="string">"1000"</span>);</span><br><span class="line">    userConfig.put(<span class="string">"bulk.flush.max.size.mb"</span>, <span class="string">"4"</span>);</span><br><span class="line">    userConfig.put(<span class="string">"bulk.flush.interval.ms"</span>, <span class="string">"60000"</span>);</span><br><span class="line"></span><br><span class="line">    ActionRequestFailureHandler failureHandler = (ActionRequestFailureHandler) (action, failure, i, indexer) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExceptionUtils.findThrowable(failure, EsRejectedExecutionException<span class="class">.<span class="keyword">class</span>).<span class="title">isPresent</span>()) </span>&#123;</span><br><span class="line">            <span class="comment">// 请求数据被拒绝，添加到队列重试</span></span><br><span class="line">            indexer.add(<span class="keyword">new</span> ActionRequest[]&#123;action&#125;);</span><br><span class="line">            log.error(<span class="string">"es reject, action: &#123;&#125;"</span>, action);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExceptionUtils.findThrowable(failure, VersionConflictEngineException<span class="class">.<span class="keyword">class</span>).<span class="title">isPresent</span>()) </span>&#123;</span><br><span class="line">            <span class="comment">// 版本冲突</span></span><br><span class="line">            log.info(<span class="string">"version conflict, action: &#123;&#125;"</span>, action);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExceptionUtils.findThrowable(failure, ElasticsearchParseException<span class="class">.<span class="keyword">class</span>).<span class="title">isPresent</span>()) </span>&#123;</span><br><span class="line">            <span class="comment">// 解析异常处理</span></span><br><span class="line">            log.info(<span class="string">"parse exception, action: &#123;&#125;"</span>, action);</span><br><span class="line">            <span class="keyword">throw</span> failure;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"todo action: &#123;&#125;"</span>, action);</span><br><span class="line">            <span class="keyword">throw</span> failure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ElasticsearchSinkFunction elasticsearchSinkFunction = (o, runtimeContext, requestIndexer) -&gt; &#123;</span><br><span class="line">        String dateStr = LocalDateTimeUtils.formatToString(o.getStmsInsertTime(), LocalDateTimeUtils.DATE_FORMAT_YM);</span><br><span class="line">        String indexName = ElasticConstants.PICKUP_NETWORK_DETAIL + ElasticConstants.SPLIT +  dateStr;</span><br><span class="line">        String indexType = ElasticConstants.PICKUP_NETWORK_DETAIL;</span><br><span class="line"></span><br><span class="line">        IndexRequest indexRequest = Requests.indexRequest()</span><br><span class="line">                .index(indexName)</span><br><span class="line">                .type(indexType)</span><br><span class="line">                .id(o.getUniqueId())</span><br><span class="line">                .source(JSON.toJSONString(o));</span><br><span class="line">        indexRequest.versionType(VersionType.EXTERNAL_GTE);</span><br><span class="line">        indexRequest.version(o.getStmsUpdateTime().getTime());</span><br><span class="line">        requestIndexer.add(indexRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> ElasticsearchSink&lt;&gt;(userConfig, transportAddresses, elasticsearchSinkFunction, failureHandler);</span><br></pre></td></tr></table></figure>

<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/08/10/flink/coding/essink/essinkstructure.png" alt="ElasticsearchSink 继承结构"></p>
<ul>
<li><p>继承 <code>ElasticsearchSinkBase</code> 类</p>
<blockquote>
<p>主要实现类</p>
</blockquote>
</li>
<li><p>继承 <code>RichSinkFunction&lt;T&gt;</code> 类</p>
<blockquote>
<p>实现 flink sink <code>open(Configuration parameters)</code>，<code>close()</code> 方法</p>
</blockquote>
</li>
<li><p>实现了 <code>CheckpointedFunction</code> 接口</p>
<blockquote>
<p>实现快照的初始化，快照存储；</p>
</blockquote>
</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="ElasticsearchSink-类"><a href="#ElasticsearchSink-类" class="headerlink" title="ElasticsearchSink 类"></a>ElasticsearchSink 类</h2><p>两种构造方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ElasticsearchSink&#125; that connects to the cluster using a &#123;<span class="doctag">@link</span> TransportClient&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userConfig The map of user settings that are used when constructing the &#123;<span class="doctag">@link</span> TransportClient&#125; and &#123;<span class="doctag">@link</span> BulkProcessor&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transportAddresses The addresses of Elasticsearch nodes to which to connect using a &#123;<span class="doctag">@link</span> TransportClient&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elasticsearchSinkFunction This is used to generate multiple &#123;<span class="doctag">@link</span> ActionRequest&#125; from the incoming element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ElasticsearchSink</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	Map&lt;String, String&gt; userConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">	List&lt;InetSocketAddress&gt; transportAddresses,</span></span></span><br><span class="line"><span class="function"><span class="params">	ElasticsearchSinkFunction&lt;T&gt; elasticsearchSinkFunction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>(userConfig, transportAddresses, elasticsearchSinkFunction, <span class="keyword">new</span> NoOpFailureHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ElasticsearchSink&#125; that connects to the cluster using a &#123;<span class="doctag">@link</span> TransportClient&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userConfig The map of user settings that are used when constructing the &#123;<span class="doctag">@link</span> TransportClient&#125; and &#123;<span class="doctag">@link</span> BulkProcessor&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transportAddresses The addresses of Elasticsearch nodes to which to connect using a &#123;<span class="doctag">@link</span> TransportClient&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elasticsearchSinkFunction This is used to generate multiple &#123;<span class="doctag">@link</span> ActionRequest&#125; from the incoming element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> failureHandler This is used to handle failed &#123;<span class="doctag">@link</span> ActionRequest&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ElasticsearchSink</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	Map&lt;String, String&gt; userConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">	List&lt;InetSocketAddress&gt; transportAddresses,</span></span></span><br><span class="line"><span class="function"><span class="params">	ElasticsearchSinkFunction&lt;T&gt; elasticsearchSinkFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">	ActionRequestFailureHandler failureHandler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">super</span>(<span class="keyword">new</span> Elasticsearch5ApiCallBridge(transportAddresses), userConfig, elasticsearchSinkFunction, failureHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NoOpFailureHandler</code> 方式不处理异常，数据写入过程中如果发生异常，直接向上抛出，阻塞现成的执行；</li>
<li><code>ActionRequestFailureHandler</code> 自定义异常数据处理，对不同的异常，针对性地做抛出、阻塞等；</li>
</ul>
<h2 id="ElasticsearchSinkBase-类"><a href="#ElasticsearchSinkBase-类" class="headerlink" title="ElasticsearchSinkBase 类"></a>ElasticsearchSinkBase 类</h2><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es BulkProcessor API 参数配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_MAX_ACTIONS = <span class="string">"bulk.flush.max.actions"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_MAX_SIZE_MB = <span class="string">"bulk.flush.max.size.mb"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_INTERVAL_MS = <span class="string">"bulk.flush.interval.ms"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_BACKOFF_ENABLE = <span class="string">"bulk.flush.backoff.enable"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_BACKOFF_TYPE = <span class="string">"bulk.flush.backoff.type"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_BACKOFF_RETRIES = <span class="string">"bulk.flush.backoff.retries"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_KEY_BULK_FLUSH_BACKOFF_DELAY = <span class="string">"bulk.flush.backoff.delay"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BulkProcessor 一个批次的最大索引数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer bulkProcessorFlushMaxActions;</span><br><span class="line"><span class="comment">// BulkProcessor 一个批次的最大容量（MB）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer bulkProcessorFlushMaxSizeMb;</span><br><span class="line"><span class="comment">// BulkProcessor flush 时间间隔（millis）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer bulkProcessorFlushIntervalMillis;</span><br><span class="line"><span class="comment">// BulkProcessor flush 策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchSinkBase.BulkFlushBackoffPolicy bulkProcessorFlushBackoffPolicy;</span><br><span class="line"><span class="comment">// 用户定义的 es 配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; userConfig;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchSinkFunction&lt;T&gt; elasticsearchSinkFunction;</span><br><span class="line"><span class="comment">// flush 异常处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ActionRequestFailureHandler failureHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flushOnCheckpoint = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> BulkProcessorIndexer requestIndexer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchApiCallBridge callBridge;</span><br><span class="line"><span class="comment">// 最大请求等待数量</span></span><br><span class="line"><span class="keyword">private</span> AtomicLong numPendingRequests = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line"><span class="comment">// es client</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Client client;</span><br><span class="line"><span class="comment">// es BulkProcessor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> BulkProcessor bulkProcessor;</span><br><span class="line"><span class="comment">// 请求异常堆栈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Throwable&gt; failureThrowable = <span class="keyword">new</span> AtomicReference();</span><br></pre></td></tr></table></figure>
<ul>
<li>es 数据的写入是基于 <code>BulkProcessor</code> 实现的</li>
</ul>
<blockquote>
<ul>
<li>实现 <code>snapshotState(FunctionSnapshotContext context)</code> 方法，请求检查点快照时调用； <code>FunctionInitializationContext</code> 执行初始化， <code>FunctionSnapshotContext</code> 调用；</li>
<li>实现 <code>initializeState(FunctionInitializationContext context)</code> 方法，当分布式执行并行函数初始化的时候调用，通常再此方法设置状态存储的数据结构；</li>
</ul>
</blockquote>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>fink</tag>
        <tag>elasticsearch</tag>
        <tag>sink</tag>
      </tags>
  </entry>
  <entry>
    <title>初识JVM GC机制</title>
    <url>/2020/03/01/java/jvm/troubleshooting/</url>
    <content><![CDATA[<p>jstack<br><a href="https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda" target="_blank" rel="noopener">https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda</a></p>
<p>jmap<br><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">http://www.eclipse.org/mat/</a><br><a href="https://help.eclipse.org/2020-06/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html" target="_blank" rel="noopener">https://help.eclipse.org/2020-06/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>trouble shooting</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 运行机制</title>
    <url>/2020/02/23/java/jvm/jmm/</url>
    <content><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title=" 导读 "></a><table><tr><font color="#009100"> 导读 </font></tr></table></h1><ol>
<li>JVM 是什么</li>
<li>Java 程序执行流程</li>
<li>Java 类加载器机制</li>
<li>JIT 工作机制</li>
</ol>
<h1 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a><table><tr><font color="#009100">JVM 是什么？</font></tr></table></h1><p>JVM（Java Virtual Machine） 是模拟执行某种指令集体系结构（ISA）的软件，是对操作系统和硬件的一种抽象（官方文档定义）。</p>
<p>在硬件和操作系统独立性的技术实现方面，他实现了以下两个方面的功能：</p>
<ul>
<li>编译代码，使其占用的空间更小；</li>
<li>保护用户免受恶意代码的攻击；</li>
</ul>
<p>HotSpot JVM 演化过程</p>
<blockquote>
<p>SUM HotSpot VM -&gt; Oracle JRockit JVM -&gt; Oracle HotSpot JVM</p>
</blockquote>
<h1 id="Java程序的执行流程"><a href="#Java程序的执行流程" class="headerlink" title=" Java程序的执行流程 "></a><table><tr><font color="#009100"> Java程序的执行流程 </font></tr></table></h1><p>Java 程序被编译成为 .class 的字节码，并加载到 JVM 中执行。</p>
<img src="/2020/02/23/java/jvm/jmm/java_work_flow.png" class>

<p>通过 Java 的运行流程可知。JVM 是程序的运行的基础，通过使用不同平台的 JVM 解决了平台的差异性问题。</p>
<p><strong>流程概述</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写 .java 源文件，并编译成 .class 字节码；</span><br><span class="line">通过 JVM 类加载机制将 .class 类加载到 JVM；</span><br><span class="line">JVM 解释 .class 字节码为机器码；</span><br><span class="line">执行解释后的机器码；</span><br><span class="line">程序运行完成，卸载类；</span><br></pre></td></tr></table></figure>

<p><strong>JVM 的生命周期</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当启动一个Java程序时，一个虚拟机实例就诞生了。程序关闭或者退出，实例也随之结束。</span><br></pre></td></tr></table></figure>

<h1 id="JVM-是如何工作的"><a href="#JVM-是如何工作的" class="headerlink" title="JVM 是如何工作的?"></a><table><tr><td bgcolor="#00ffff">JVM 是如何工作的?</td></tr></table></h1><p>JVM分为三个子系统</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类加载器子系统</span><br><span class="line">运行时数据区</span><br><span class="line">执行引擎</span><br></pre></td></tr></table></figure>

<img src="/2020/02/23/java/jvm/jmm/jvm_arch.png" class>

<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>Java的动态类加载功能由类加载器子系统处理。在运行时首次引用类时初始化类文件。类的加载是将 .class 文件加载到 JVM 的过程。</p>
<ul>
<li>两种触发类加载方式（显示、隐式）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示加载</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 隐示（动态加载）</span></span><br><span class="line">Class clasz = Class.forName(someClassName);</span><br><span class="line">Object obj = clasz.newInstance();</span><br></pre></td></tr></table></figure>

<h3 id="加载（loading）"><a href="#加载（loading）" class="headerlink" title="加载（loading）"></a>加载（loading）</h3><p>Heap 空间生成这个类的对象，方法区生成该类的描述信息，作为这个类的各种数据入口。</p>
<p>多种类加载器 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">引导类加载(Bootstrap) </span><br><span class="line">	加载JAVA_HOME/lib目录中，被JVM认可的类(-Xbootclasspath可重新指定目录)。</span><br><span class="line"></span><br><span class="line">扩展类加载(Extension) </span><br><span class="line">	加载JAVA_HOME/lib/ext目录中，被JVM认可的类(java.ext.dirs重新指定目录)。</span><br><span class="line"></span><br><span class="line">应用类加载（Application)</span><br><span class="line">	加载用户指定的classpath目录上的类。</span><br><span class="line"></span><br><span class="line">用户自定义类加载(User-Defined)</span><br><span class="line">	用户继承java.lang.ClassLoader，自定义类加载器。</span><br></pre></td></tr></table></figure>

<p>JVM 使用双亲委派机制进行类的加载。</p>
<p><strong>双亲委派机制</strong>：当一个类收到类加载任务，会先委托父类加载器去完成，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</p>
<img src="/2020/02/23/java/jvm/jmm/classload.png" class>

<h3 id="链接（linking）"><a href="#链接（linking）" class="headerlink" title="链接（linking）"></a>链接（linking）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">验证</span><br><span class="line">	确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</span><br><span class="line"></span><br><span class="line">准备</span><br><span class="line">	在方法区中分配类变量所使用的内存空间。</span><br><span class="line"></span><br><span class="line">解析</span><br><span class="line">	所有符号内存引用将被来自方法区域的原始引用所替换。</span><br></pre></td></tr></table></figure>

<h3 id="初始化（initialzation）"><a href="#初始化（initialzation）" class="headerlink" title="初始化（initialzation）"></a>初始化（initialzation）</h3><p>初始化过程中，所有静态变量都将被赋初始值，并且静态块和构造器方法也会被执行。<br>以下几种情况不会执行类初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</span><br><span class="line">定义对象数组，不会触发该类的初始化。</span><br><span class="line">常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</span><br><span class="line">通过类名获取Class对象，不会触发类的初始化。</span><br><span class="line">通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化。</span><br><span class="line">通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</span><br></pre></td></tr></table></figure>

<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM 运行时的内存主要有五个部分，其中堆和方法区是线程共享的数据区，而程序计数器、Java虚拟机栈和本地方法栈是线程私有的数据区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 线程共享数据区</span><br><span class="line"></span><br><span class="line">堆(Heap)	</span><br><span class="line"></span><br><span class="line">	堆内存生命周期与 JVM 相同，在线程间共享访问。</span><br><span class="line">	主要存放对象或数组实例。是 GC 的主要对象。  </span><br><span class="line">	当 JVM 申请不到足够内存时，会抛出 OutOfMemoryException。</span><br><span class="line"></span><br><span class="line">	配置参数：-Xms512M -Xmn2048M</span><br><span class="line"></span><br><span class="line">	由于线程共享堆内存，所以在线程安全上主要从两个方面去解决：  </span><br><span class="line">	a. 加锁互斥访问；</span><br><span class="line">	b. 线程本地分配缓冲区(ThreadLocal)； </span><br><span class="line">	</span><br><span class="line">方法区(Method Area)</span><br><span class="line"></span><br><span class="line">	方法区生命周期与 JVM 相同，被多个线程共享。</span><br><span class="line">	主要存放类信息和运行时常量池，每个加载的类都会在方法区形成一个与之对应的类信息的数据结构。  </span><br><span class="line">	包括类名、直接超类、实现的接口列表等。</span><br><span class="line"></span><br><span class="line">	当 JVM 申请不到足够内存时，会抛出 OutOfMemoryException。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 线程私有数据区</span><br><span class="line"></span><br><span class="line">程序计数器(Program Counter Register)</span><br><span class="line"></span><br><span class="line">	程序计数器生命周期与线程相同，是线程私有的。  </span><br><span class="line">	若当前正在执行 Java 方法，程序计数器中存放下一条字节码指令的地址。</span><br><span class="line">	程序计数器是唯一一块没有规定会抛异常的区域。</span><br><span class="line"></span><br><span class="line">Java 虚拟机栈(Java Virtual Mathine Stacks)</span><br><span class="line"></span><br><span class="line">	Java 虚拟机栈的生命周期与线程相同，是线程私有的。</span><br><span class="line">	主要存放栈帧(Frame)，用于保存方法调用和返回，存储局部变量和中间结果。</span><br><span class="line"></span><br><span class="line">	配置参数：-Xss320KB</span><br><span class="line">	</span><br><span class="line">	可能会有两种异常：  </span><br><span class="line">	a. StackOverFlowException（栈的深度大于一定的阀值）</span><br><span class="line">	b. OutOfMemoeryException（申请不到足够的内存）</span><br><span class="line"></span><br><span class="line">本地方法栈(Native Method Stacks)</span><br><span class="line"></span><br><span class="line">	本地方法栈生命周期与线程相同，是线程私有的。</span><br><span class="line">	于支持本地方法的调用，也叫做 &#96;C Stack&#96;。</span><br><span class="line">	允许固定大小，或者根据计算需要动态扩容。</span><br><span class="line">	</span><br><span class="line">	可能会有两种异常：  </span><br><span class="line">	a. StackOverFlowException（栈的深度大于一定的阀值）</span><br><span class="line">	b. OutOfMemoeryException（动态扩容下，如果申请不到足够的内存）</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/williamjie/p/11089619.html" target="_blank" rel="noopener">JVM详细配置参数</a></p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>被分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐个执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解释器</span><br><span class="line">	解释器更快地解释字节码，但执行速度很慢。</span><br><span class="line">	解释器的缺点是，当一个方法被多次调用时，每次都需要一个新的解释。</span><br><span class="line"></span><br><span class="line">JIT编译器</span><br><span class="line">	JIT编译器消除了解释器的缺点。</span><br><span class="line">	执行引擎将在转换字节码时使用解释器的帮助，但是当它发现重复的代码时，它使用JIT编译器，JIT编译整个字节码并将其更改为本机代码。</span><br><span class="line">	此本机代码将直接用于重复的方法调用，从而提高系统的性能。</span><br><span class="line"></span><br><span class="line">中间代码生成器</span><br><span class="line">	生成中间代码</span><br><span class="line"></span><br><span class="line">代码优化器</span><br><span class="line">	负责优化上面生成的中间代码</span><br><span class="line"></span><br><span class="line">目标代码生成器</span><br><span class="line">	负责生成机器代码或本地代码</span><br><span class="line"></span><br><span class="line">分析器</span><br><span class="line">	一个特殊的组件，负责寻找热点，即方法是否被多次调用。</span><br><span class="line"></span><br><span class="line">垃圾收集器</span><br><span class="line">	收集和删除未引用的对象。</span><br><span class="line">	可以通过调用 System.gc()触发垃圾收集，但不能保证执行。</span><br><span class="line">	JVM的垃圾收集收集创建的对象。</span><br></pre></td></tr></table></figure>

<h2 id="JIT-工作机制"><a href="#JIT-工作机制" class="headerlink" title="JIT 工作机制"></a>JIT 工作机制</h2><p>JIT (Just In Time) compiler 及时编译器，在运行时，JIT会把翻译后的机器码保存起来，以备下次使用。工作在 .class 字节码到机器码转换的过程。</p>
<p>工作原理：  </p>
<img src="/2020/02/23/java/jvm/jmm/jit_process.png" class>

<p>所以 JIT 是通过减少重复翻译机器码来提升性能的。JIT 编译器在运行程序时有两种编译模式可以选择，并且其会在运行时决定使用哪一种以达到最优性能。（这样已经能解决大部分问题，在 JVM 调优中，相对而言需要做的比较少）  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM Server 模式</span><br><span class="line">	由于采用了相对重量级代号为 C2 的编译器，速度较慢，但是一旦运行起来后，性能将会有很大的提升；</span><br><span class="line">JVM Client 模式</span><br><span class="line">	由于采用了轻量的编译器 C1，启动速度快。</span><br></pre></td></tr></table></figure>

<p><a href="http://www.oracle.com/technetwork/java/javase/tech/exactoptions-jsp-141536.html" target="_blank" rel="noopener">了解 JIT 配置参数</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><td bgcolor="#00ffff">总结</td></tr></table></h1><p>通过 Java 程序的运行流程，了解到了 JVM 在 Java 运行中的作用。另外摘录了 JVM 相关的知识点，辅助和加强对 JVM 体系结构的认识。本文仅仅是笔记的整理，详细的知识点，还请参考下面的文档。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><td bgcolor="#00ffff">参考文档</td></tr></table></h1><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</a><br><a href="https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works" target="_blank" rel="noopener">https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works</a><br><a href="http://www.oracle.com/technetwork/java/javase/tech/exactoptions-jsp-141536.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/tech/exactoptions-jsp-141536.html</a><br><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a><br><a href="https://javapapers.com/java/java-garbage-collection-introduction" target="_blank" rel="noopener">https://javapapers.com/java/java-garbage-collection-introduction</a><br><a href="https://javapapers.com/java/how-java-garbage-collection-works" target="_blank" rel="noopener">https://javapapers.com/java/how-java-garbage-collection-works</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html</a><br><a href="https://docs.oracle.com/javase/10/gctuning/factors-affecting-garbage-collection-performance.htm" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/gctuning/factors-affecting-garbage-collection-performance.htm</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html</a><br><a href="https://javainterviewpoint.com/category/java/" target="_blank" rel="noopener">https://javainterviewpoint.com/category/java/</a><br><a href="https://www.cnblogs.com/liululee/archive/2019/09/04/11461998.html" target="_blank" rel="noopener">https://www.cnblogs.com/liululee/archive/2019/09/04/11461998.html</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html</a><br><a href="https://docs.oracle.com/javase/10/gctuning/toc.htm" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/gctuning/toc.htm</a>  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/02/23/redis/</url>
    <content><![CDATA[<h2 id="docker-运行-redis-服务"><a href="#docker-运行-redis-服务" class="headerlink" title="docker 运行 redis 服务"></a>docker 运行 redis 服务</h2><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name redis-server -p 6379:6379 -v /Users/zj/docker/redis/data:/data  -d redis:3.2 --appendonly yes --requirepass "123456"</span><br></pre></td></tr></table></figure>

<h2 id="持续更新中。。。"><a href="#持续更新中。。。" class="headerlink" title="持续更新中。。。"></a>持续更新中。。。</h2>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>hbase 基础概念</title>
    <url>/2020/02/23/hbase-start/</url>
    <content><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a><table><tr><font color="#009100">导读</font></tr></table></h1><ol>
<li>HBase 是什么？有什么特性？</li>
<li>HBase 有什么优势？</li>
<li>HBase 使用哪些应用场景？</li>
<li>HBase 有哪些组件，分别具有什么功能？</li>
<li>HBase Region 如何进行分区及定位？</li>
<li>HBase 数据读写流程？</li>
<li>HBase WAL 机制是什么？</li>
<li>HBase 是如何管理 Region 的？</li>
</ol>
<h1 id="NoSQL-HBase"><a href="#NoSQL-HBase" class="headerlink" title="NoSQL-HBase"></a><table><tr><font color="#009100">NoSQL-HBase</font></tr></table></h1><p>HBase 是一个开源的、分布式的、版本化的非关系型数据库，它利用 Hadoop 分布式文件系统（Hadoop Distributed File System，HDFS）提供分布式数据存储。可以进行随机访问的存取和检索数据的存储平台，存储结构化和半结构化的数据.</p>
<p>HBase 特性：</p>
<ul>
<li>单条记录强一致性读写。</li>
<li>自动分片。</li>
<li>RegionServer 自动故障转移。</li>
<li>Hadoop/HDFS 整合。</li>
<li>支持 MapReduce。</li>
<li>支持 Java API。</li>
<li>支持 Thrift/REST API。</li>
<li>Block Cache 和 Bloom Filters 性能查询优化。</li>
<li>基于网页的操作管理。</li>
</ul>
<p>更多信息：<br><a href="https://hbase.apache.org/book.html#arch.overview.nosql" target="_blank" rel="noopener">https://hbase.apache.org/book.html#arch.overview.nosql</a></p>
<h1 id="HBase-优势"><a href="#HBase-优势" class="headerlink" title="HBase 优势"></a><table><tr><font color="#009100">HBase 优势</font></tr></table></h1><h2 id="容量巨大"><a href="#容量巨大" class="headerlink" title="容量巨大"></a>容量巨大</h2><p>HBase 单表支持百亿行、百万列数据，可横向和纵向两个维度插入数据，弹性好。在限定某个列的情况下，对单个表存储百亿甚至更多的数据没有性能问题。</p>
<p>HBase 采用 LSM 树作为内部数据存储结构，这种结构会周期性地将较小文件合并成大文件，以减少对磁盘的访问。  </p>
<p>LSM的原理：将对数据的修改增量保存在内存中，达到指定大小限制之后批量把数据flush到磁盘中，磁盘中树定期可以做merge操作，合并成一棵大树，以优化读性能。不过读取的时候稍微麻烦一些，读取时看这些数据在内存中，如果未能命中内存，则需要访问较多的磁盘文件。</p>
<p>更多关于LSM-tree：<br><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf" target="_blank" rel="noopener">https://www.cs.umb.edu/~poneil/lsmtree.pdf</a><br><a href="https://www.researchgate.net/publication/226763355_The_log-structured_merge-tree_LSM-tree" target="_blank" rel="noopener">https://www.researchgate.net/publication/226763355_The_log-structured_merge-tree_LSM-tree</a></p>
<h2 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h2><p>HBase 是面向列的存储和权限控制的，它里面的每个列是单独存储的，且支持基于列的独立检索。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191114/6-191114094154Q0.gif" alt></p>
<p>行存储里的一张表的数据都放在一起，但在列存储里是按照列分开保存的。<br>数据的插入和更新操作时，行存储会相对容易。<br>查询操作时，行存储需要读取所有的数据，而列存储则只需要读取相关列，可以大幅降低系统 I/O 吞吐量。</p>
<h2 id="稀疏性"><a href="#稀疏性" class="headerlink" title="稀疏性"></a>稀疏性</h2><p>通常在传统的关系性数据库中，每一列的数据类型是事先定义好的，会占用固定的内存空间，在此情况下，属性值为空（NULL）的列也需要占用存储空间。</p>
<p>而在 HBase 中的数据都是以字符串形式存储的，为空的列并不占用存储空间，因此 HBase 的列存储解决了数据稀疏性的问题，在很大程度上节省了存储开销。所以 HBase 通常可以设计成稀疏矩阵，同时这种方式比较接近实际的应用场景。</p>
<h2 id="扩展性强"><a href="#扩展性强" class="headerlink" title="扩展性强"></a>扩展性强</h2><p>HBase 工作在 HDFS 之上，理所当然地支持分布式表，也继承了 HDFS 的可扩展性。<br>HBase 表根据 Region 大小进行分区，分别存在集群中不同的节点上，当添加新的节点时，集群就重新调整，在新的节点启动 HBase 服务器，动态地实现扩展。</p>
<p>更多关于HDFS：<br><a href="http://c.biancheng.net/view/6502.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6502.html</a></p>
<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>HBase 运行在 HDFS 上，HDFS 的多副本存储可以让它在岀现故障时自动恢复，同时 HBase 内部也提供 WAL 和 Replication 机制。</p>
<p>WAL（Write-Ahead-Log）预写日志是在 HBase 服务器处理数据插入和删除的过程中用来记录操作内容的日志，保证了数据写入时不会因集群异常而导致写入数据的丢失；而 Replication 机制是基于日志操作来做数据同步的。</p>
<p>当集群中单个节点出现故障时，协调服务组件 ZooKeeper 通知集群的主节点，将故障节点的 HLog 中的日志信息分发到各从节点进行数据恢复</p>
<h1 id="HBase-使用场景"><a href="#HBase-使用场景" class="headerlink" title="HBase 使用场景"></a><table><tr><font color="#009100">HBase 使用场景</font></tr></table></h1><p>HBase 解决不了所有的问题，但是针对某些特点的数据可以使用 HBase 高效地解决，如以下的应用场景。</p>
<ol>
<li>数据模式是动态的或者可变的，且支持半结构化和非结构化的数据。</li>
<li>数据库中的很多列都包含了很多空字段，在 HBase 中的空字段不会像在关系型数据库中占用空间。</li>
<li>需要很高的吞吐量，瞬间写入量很大。</li>
<li>数据有很多版本需要维护，HBase 利用时间戳来区分不同版本的数据。</li>
<li>具有高可扩展性，能动态地扩展整个存储系统。</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>Facebook 公司的 Social Inbox 系统，使用 HBase 作为消息服务的基础存储设施，每月可处理几千亿条的消息；</li>
<li>Yahoo 公司使用 HBase 存储检查近似重复的指纹信息的文档，它的集群当中分别运行着 Hadoop 和 HBase，表中存了上百万行数据；</li>
<li>Adobe 公司使用 Hadoop+HBase 的生产集群，将数据直接持续地存储在 HBase 中，并将 HBase 作为数据源进行 MapReduce 的作业处理；</li>
<li>Apache 公司使用 HBase 来维护 Wiki 的相关信息。</li>
</ul>
<p>更多案例：<br><a href="http://c.biancheng.net/view/6514.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6514.html</a></p>
<h1 id="HBase的组件和功能"><a href="#HBase的组件和功能" class="headerlink" title="HBase的组件和功能"></a><table><tr><font color="#009100">HBase的组件和功能</font></tr></table></h1><p>HBase 各个组件：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191114/6-191114125630422.gif" alt></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>整个 HBase 系统的入口，使用 HBase RPC 机制于 HMaster 和 RegionServer 进行通信。  </p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>ZooKeeper 是一个高性能、集中化、分布式应用程序协调服务。  </p>
<p>协调任务如下： </p>
<ol>
<li>Master 选举</li>
<li>系统容错（协同HMaster管理RegionServer）</li>
<li>Region 元数据管理  </li>
</ol>
<blockquote>
<p>Region 元数据（Meta表）存储在 Zookeeper 中，客户端发起新的查询请求需要查询Meta表获取 Region 位置。  </p>
</blockquote>
<ol start="4">
<li>Region 状态管理</li>
</ol>
<blockquote>
<p>HBase 集群中 Region 会经常发生变更，其原因可能是系统故障，配置修改，或者是 Region 的分裂和合并。只要 Region 发生变化，就需要让集群的所有节点知晓，否则就会出现某些事务性的异常。</p>
</blockquote>
<ol start="5">
<li>提供 Meta 表存储位置</li>
</ol>
<blockquote>
<p>在 HBase 集群中，数据库表信息、列族信息及列族存储位置信息都属于元数据。这些元数据存储在 Meta 表中，而 Meta 表的位置入口由 ZooKeeper 来提供。</p>
</blockquote>
<h2 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h2><p>HMaster 是 HBase 集群中的主服务器，负责监控集群中的所有 RegionServer，并且是所有元数据更改的接口。</p>
<p>在分布式集群中，HMaster 服务器通常运行在 HDFS 的 NameNode上，HMaster 通过 ZooKeeper 来避免单点故障，在集群中可以启动多个 HMaster，但 ZooKeeper 的选举机制能够保证同时只有一个 HMaster 处于 Active 状态，其他的 HMaster 处于热备份状态。</p>
<p>HMaster 主要负责表和 Region 的管理工作。</p>
<ol>
<li>管理用户对表的增、删、改、查操作。</li>
<li>管理 RegionServer 的负载均衡，调整 Region 的分布。</li>
<li>Region 的分配和移除。</li>
<li>处理 RegionServer 的故障转移。</li>
</ol>
<h2 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h2><p>RegionServer 主要负责响应用户的请求，向 HDFS 读写数据。一般在分布式集群中，RegionServer 运行在 DataNode 服务器上，实现数据的本地性。</p>
<blockquote>
<p>RegionServer 是 HBase 中最核心的模块，其内部管理了一系列 Region 对象，每个 Region 由多个 HStore 组成，每个 HStore 对应表中一个列族的存储。</p>
</blockquote>
<p>每个 RegionServer 包含多个 Region，它负责的功能如下:</p>
<ol>
<li>处理分批给它的 Region。</li>
<li>处理客户端读写请求。</li>
<li>刷新缓存到 HDFS 中。</li>
<li>处理 Region 分片。</li>
<li>执行压缩。</li>
</ol>
<h1 id="HBase-Region分区及定位"><a href="#HBase-Region分区及定位" class="headerlink" title="HBase Region分区及定位"></a><table><tr><font color="#009100">HBase Region分区及定位</font></tr></table></h1><p>在 HBase 中，表的所有行都是按照 RowKey 的字典序排列的，表在行的方向上分割为多个分区（Region）。<br><img src="http://c.biancheng.net/uploads/allimg/191115/6-191115164IK02.gif" alt><br>每张表一开始只有一个 Region，但是随着数据的插入，HBase 会根据一定的规则将表进行水平拆分，形成两个 Region。当表中的行越来越多时，就会产生越来越多的 Region，而这些 Region 无法存储到一台机器上时，则可将其分布存储到多台机器上。</p>
<p>Master 主服务器把不同的 Region 分配到不同的 Region 服务器上，同一个行键的 Region 不会被拆分到多个 Region 服务器上。每个 Region 服务器负责管理一个 Region，通常在每个 Region 服务器上会放置 10 ~ 1000 个 Region，HBase中Region 的物理存储如下图所示。<br><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151649162H.gif" alt><br>客户端在插入、删除、查询数据时需要知道哪个 Region 服务器上存储所需的数据，这个查找 Region 的过程称为 Region 定位。<br>HBase 中的每个 Region 由三个要素组成，包括 Region 所属的表、第一行和最后一行。其中，第一个 Region 没有首行，最后一个 Region 没有末行。每个 Region 都有一个 RegionlD 来标识它的唯一性，Region 标识符就可以表示成“表名+开始行键+RegionID”。</p>
<h2 id="Meta-表"><a href="#Meta-表" class="headerlink" title="Meta 表"></a>Meta 表</h2><p>Meta 表的每个条目包含两项内容，一项是 Region 标识符，另一项是 Region 服务器标识。这个条目就表示 Region 和 Region 服务器之间的对应关系，从而就可以使用户知道某个 Region 存储在哪个 Region 服务器中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> scan <span class="string">'hbase:meta'</span></span></span><br><span class="line">ROW                                                  COLUMN+CELL                                                                                                                                        </span><br><span class="line">hbase:namespace,,1582440367299.c349a23aa3536a0c26e9 column=info:regioninfo, timestamp=1593651118107, value=&#123;ENCODED =&gt; c349a23aa3536a0c26e96e5f4201c03c, NAME =&gt; 'hbase:namespace,,1582440367299.c349a23aa36e5f4201c03c.536a0c26e96e5f4201c03c.', STARTKEY =&gt; '', ENDKEY =&gt; ''&#125;</span><br></pre></td></tr></table></figure>

<p>Meta 表里有一个列族 info。info 包含了三个列，分别为 RegioninfoServer 和 Serverstartcode。Regionlnfo中记录了 Region 的详细信息，包括行键范围 StartKey 和 EndKey、列族列表和属性。</p>
<h2 id="Region-定位"><a href="#Region-定位" class="headerlink" title="Region 定位"></a>Region 定位</h2><p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151AI1V8.gif" alt></p>
<p>Hbase 二层架构的 Region 定位流程：</p>
<ol>
<li>找 Meta 表位置信息<blockquote>
<p>通过 ZooKeeper 中的 /hbase/meta-region-server 先找到 Meta 表所在的 Region 服务器信息，从中获取分区 Meta 表位置。</p>
</blockquote>
</li>
<li>根据 Meta 表位置信息定位 Region，找出 Region 所在的 Region 服务器。 </li>
<li>通过 Mate 表得到所需的表和行键所在的 Region 信息，然后从 Region 服务器上找到所需的数据。</li>
</ol>
<p>详细信息：<br><a href="http://c.biancheng.net/view/6528.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6528.html</a></p>
<h1 id="HBase-数据的读写流程"><a href="#HBase-数据的读写流程" class="headerlink" title="HBase 数据的读写流程"></a><table><tr><font color="#009100">HBase 数据的读写流程</font></tr></table></h1><p>HBase 的核心模块是 Region 服务器。Region 服务器由多个 Region 块构成，Region 块中存储一系列连续的数据集。Region 服务器主要构成部分是 HLog 和 Region 块。HLog 记录该 Region 的操作日志。</p>
<p>Region 对象由多个 Store 组成，每个 Store 对应当前分区中的一个列族，每个 Store 管理一块内存。当 MemStore 中的数据达到一定条件时会写入 StoreFile 文件中，因此每个 Store 包含若干个 StoreFile 文件。StoreFile 文件对应 HDFS 中的 HFile 文件。</p>
<p>HBase 群集数据的构成如图所示。<br><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151FG1X5.gif" alt></p>
<h2 id="MemStore"><a href="#MemStore" class="headerlink" title="MemStore"></a>MemStore</h2><p>当 Region 服务器收到写请求的时候，Region 服务器会将请求转至相应的 Region。数据先被写入 MemStore，当到达一定的阈值时，MemStore 中的数据会被刷新到 HFile 中进行持久化存储。</p>
<p>HBase 将最近接收到的数据缓存在 MemStore 中，在持久化到 HDFS 之前完成排序，再顺序写入 HDFS，为后续数据的检索进行优化。因为 MemStore 缓存的是最近增加的数据，所以也提高了对近期数据的操作速度。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store 是 Region 服务器的核心，存储的是同一个列族下的数据，每个 Store 包含一块 MemStore 和 StoreFile（ 0 个或多个）。StoreFile 是 HBase 中最小的数据存储单元。</p>
<p>数据写入 MemStore 缓存，当 MemStore 缓存满时，内存中的数据会持久化到磁盘中一个 StoreFile 文件中，随着 StoreFile 文件数量的不断增加，数量达到一个阈值后，就会促使文件合并成一个大的 StoreFile 文件。</p>
<p>由于 StoreFile 文件的不断合并，造成 StoreFile 文件的大小超过一定的阈值，因此，会促使文件进行分裂操作。同时，当前的一个父 Region 会被分成两个子 Region, 父 Region 会下线，新分裂出的两个子 Region 会被 Master 分配到相应的 Regio n服务器上。</p>
<p>Store 的合并和分裂过程如下图所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151G132A4.gif" alt></p>
<h2 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h2><p>将 MemStore 内存中的数据写入 StoreFile 文件中，StoreFile 底层是以 HFile 格式保存的。</p>
<p>HFile 的存储格式如下图所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151G225A3.gif" alt></p>
<p>HFile 文件是不定长的，长度固定的只有其中的两块：Trailer 和 File Info。Trailer 中有指针指向其他数据块的起始点，File Info 记录了文件的一些 Meta 信息。每个 Data 块的大小可以在创建一个 Table 的时候通过参数指定（默认块大小为 64KB）。每个 Data 块除了开头的 Magic 以外就是由一个键值对拼接而成的，Magic 内容是一些随机数字，用于防止数据损坏。</p>
<p>HFile 里面的每个键值对就是一个简单的 Byte 数组。但是这个 Byte 数组里面包含了很多项， 并且有固定的结构，其具体结构如图所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151G400W1.gif" alt></p>
<p>键值对结构以两个固定长度的数值开始，分别表示 Key 的长度和 Value 的长度。紧接着是 Key，Key 以 RowLength 开始，是固定长度的数值，表示 RowKey 的长度；接着是 Row，然后是固定长度的数值 ColumnFamilyLength，表示 Family 的长度；之后是 Family 列族，接着是 Qualifier 列标识符，Key 最后以两个固定长度的数值 Time Stamp 和 Key Type(Put/Delete) 结束。Value部分没有这么复杂的结构，就是纯粹的二进制数据。</p>
<h2 id="HBase-数据写入流程"><a href="#HBase-数据写入流程" class="headerlink" title="HBase 数据写入流程"></a>HBase 数据写入流程</h2><p>1) 客户端访问 ZooKeeper，从 Meta 表得到写入数据对应的 Region 信息和相应 的Region 服务器。</p>
<p>2) 客户端访问相应的 Region 服务器，把数据分别写入 HLog 和 MemStore。MemStore 数据容量有限，当达到一个阈值后，则把数据写入磁盘文件 StoreFile 中，在 HLog 文件中写入一个标记，表示 MemStore 缓存中的数据已被写入 StoreFile 中。如果 MemStore 中的数据丢失，则可以从 HLog 上恢复。</p>
<p>3) 当多个 StoreFile 文件达到阈值后，会触发 Store.compact() 将多个 StoreFile 文件合并为一个 大文件。</p>
<h2 id="HBase-数据读取流程"><a href="#HBase-数据读取流程" class="headerlink" title="HBase 数据读取流程"></a>HBase 数据读取流程</h2><p>1) 客户端先访问 ZooKeeper，从 Meta 表读取 Region 信息对应的服务器。</p>
<p>2) 客户端向对应 Region 服务器发送读取数据的请求，Region 接收请求后，先从 MemStore 查找数据；如果没有，再到 StoreFile 上读取，然后将数据返回给客户端。<br><img src="https://hbase.apache.org/images/offheap-overview.png" alt></p>
<h1 id="HBase-WAL机制"><a href="#HBase-WAL机制" class="headerlink" title="HBase WAL机制"></a><table><tr><font color="#009100">HBase WAL机制</font></tr></table></h1><p>Region服务器发生故障时， MemStore 缓存中还没有被写入文件的数据会全部丢失。因此，HBase 采用 HLog 来保证系统发生故障时能够恢复到正常的状态。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151I13B93.gif" alt></p>
<p>每个 Region 服务器都有一个 HLog 文件，同一个 Region 服务器的 Region 对象共用一个 HLog，HLog 是一种预写日志（Write Ahead Log）文件。</p>
<p>预写日志文件（WAL）保存在 HDFS 上，目录：/hbase/WALs/ , 每个子目录对应一个 Region 。</p>
<p>用户更新数据必须先被记入日志后才能写入 MemStore 缓存，当缓存内容对应的日志已经被写入磁盘后，即日志写成功后，缓存的内容才会被写入磁盘。</p>
<p>ZooKeeper 会实时监测每个 Region 服务器的状态，当某个 Region 服务器发生故障时，ZooKeeper 会通知 Master，Master 首先会处理该故障 Region 服务器上遗留的 HLog 文件。</p>
<p>系统会根据每条日志记录所属的 Region 对象对 HLog 数据进行拆分，并分别存放到相应 Region 对象的目录下。再将失效的 Region 重新分配到可用的 Region 服务器中，并在可用的 Region 服务器中重新进行日志记录中的各种操作， 把日志记录中的数据写入 MemStore 然后刷新到磁盘的 StoreFile 文件中，完成数据恢复。</p>
<p>Region 对象共用一个 HLog 的方式中，多个 Region 对象在进行更新操作需要修改日志时，只需要不断地把日志记录追加到单个日志文件中，而不需要同时打开、写入多个日志文件中，因此可以减少磁盘寻址次数，提高对表的写操作性能。</p>
<p><a href="https://hbase.apache.org/book.html#wal" target="_blank" rel="noopener">https://hbase.apache.org/book.html#wal</a><br><a href="http://c.biancheng.net/view/6533.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6533.html</a></p>
<h1 id="HBase-Region管理"><a href="#HBase-Region管理" class="headerlink" title="HBase Region管理"></a><table><tr><font color="#009100">HBase Region管理</font></tr></table></h1><p>Region 是 HBase 集群的负载均衡和数据分发的基本单元。当 HBase中 表的容量非常庞大时，用户就需要将表中的内容分布到多台机器上。那么，需要根据行键的值对表中的行进行划分，每个行区间构成一个 Region，一个 Region 包含了位于某个阈值区间的所有数据。</p>
<h2 id="HFile-合并"><a href="#HFile-合并" class="headerlink" title="HFile 合并"></a>HFile 合并</h2><p>每个 RegionServer 包含多个 Region，而每个 Region 又对应多个 Store，每一个 Store 对应表中一个列族的存储，且每个 Store 由一个 MemStore 和多个 StoreFile 文件组成。</p>
<p>StoreFile 在底层文件系统中由 HFile 实现，也可以把 Store 看作由一个 MemStore 和多个 HFile 文件组成。MemStore 充当内存写缓存，默认大小 64MB，当 MemStore 超过阈值时，MemStore 中的数据会刷新到一个新的 HFile 文件中来持久化存储。</p>
<p>久而久之，每个 Store 中的 HFile 文件会越来越多，I/O 操作的速度也随之变慢，读写也会延时，导致慢操作。因此，需要对 HFile 文件进行合并，让文件更紧凑，让系统更有效率。</p>
<p>HFile 的合并分为两种类型，分别是 Minor 合并和 Major 合并。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151KF3V3.gif" alt></p>
<h3 id="Minor-合并"><a href="#Minor-合并" class="headerlink" title="Minor 合并"></a>Minor 合并</h3><p>Minor 合并是把多个小 HFile 合并生成一个大的 HFile。<br>执行合并时，HBase 读出已有的多个 HFile 的内容，把记录写入一个新文件中。然后把新文件设置为激活状态，并标记旧文件为删除。</p>
<h3 id="Major-合并"><a href="#Major-合并" class="headerlink" title="Major 合并"></a>Major 合并</h3><p>Major 合并针对的是给定 Region 的一个列族的所有 HFile，将 Store 中的所有 HFile 合并成一个大文件，有时也会对整个表的同一列族的 HFile 进行合并，这是一个耗时和耗费资源的操作，会影响集群性能。</p>
<h2 id="Region-拆分"><a href="#Region-拆分" class="headerlink" title="Region 拆分"></a>Region 拆分</h2><p>Region 拆分是 HBase 能够拥有良好扩展性的最重要因素。一旦 Region 的负载过大或者超过阈值时，它就会被分裂成两个新的 Region.</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191118/6-19111P9141D39.gif" alt></p>
<p>这个过程是由 RegionServer 完成的，其拆分流程如下。</p>
<ol>
<li>将需要拆分的 Region下线，阻止所有对该 Region 的客户端请求，Master 会检测到 Region 的状态为 SPLITTING。</li>
<li>将一个 Region 拆分成两个子 Region，先在父 Region下建立两个引用文件，分别指向 Region 的首行和末行，这时两个引用文件并不会从父 Region 中复制数据。</li>
<li>之后在 HDFS 上建立两个子 Region 的目录，分别复制上一步建立的引用文件，每个子 Region 分别占父 Region 的一半数据。复制登录完成后删除两个引用文件。</li>
<li>完成子 Region 创建后，向 Meta 表发送新产生的 Region 的元数据信息。</li>
<li>将 Region 的拆分信息更新到 HMaster，并且每个 Region 进入可用状态。</li>
</ol>
<p>拆分策略：</p>
<ol>
<li>ConstantSizeRegionSplitPolicy</li>
<li>IncreasingToUpperBoundRegionSplitPolicy</li>
<li>SteppingSplitPolicy</li>
<li>DisabledRegionSplitPolicy</li>
</ol>
<h2 id="Region-合并"><a href="#Region-合并" class="headerlink" title="Region 合并"></a>Region 合并</h2><p>从 Region 的拆分过程中可以看到，随着表的增大，Region 的数量也越来越大。如果有很多 Region，它们中 MemStore 也过多，会频繁出现数据从内存被刷新到 HFile 的操作，从而会对用户请求产生较大的影响，可能阻塞该 Region 服务器上的更新操作。过多的 Region 会增加 ZooKeeper 的负担。</p>
<p>因此，当 Region 服务器中的 Region 数量到达阈值时，Region 服务器就会发起 Region 合并，其合并过程如下。</p>
<ol>
<li>客户端发起 Region 合并处理，并发送 Region 合并请求给 Master。</li>
<li>Master 在 Region 服务器上把 Region 移到一起，并发起一个 Region 合并操作的请求。</li>
<li>Region 服务器将准备合并的 Region下线，然后进行合并。</li>
<li>从 Meta 表删除被合并的 Region 元数据，新的合并了的 Region 的元数据被更新写入 Meta 表中。</li>
<li>合并的 Region 被设置为上线状态并接受访问，同时更新 Region 信息到 Master。</li>
</ol>
<h2 id="Region-负载均衡"><a href="#Region-负载均衡" class="headerlink" title="Region 负载均衡"></a>Region 负载均衡</h2><p>Region 的负载均衡由 Master 来完成，Master 有一个内置的负载均衡器，在默认情况下，均衡器每 5 分钟运行一次，用户可以配置。负载均衡操作分为两步进行：首先生成负载均衡计划表， 然后按照计划表执行 Region 的分配。</p>
<p>执行负载均衡前要明确，在以下几种情况时，Master 是不会执行负载均衡的。</p>
<ul>
<li>均衡负载开关关闭。</li>
<li>Master 没有初始化。</li>
<li>当前有 Region 处于拆分状态。</li>
<li>当前集群中有 Region 服务器出现故障。</li>
</ul>
<p>Master 内部使用一套集群负载评分的算法，来评估 HBase 某一个表的 Region 是否需要进行重新分配。这套算法分别从 Region 服务器中 Region 的数目、表的 Region 数、MenStore 大小、 StoreFile 大小、数据本地性等几个维度来对集群进行评分，评分越低代表集群的负载越合理。</p>
<p>负载均衡策略：  </p>
<ol>
<li>RandomRegionPicker</li>
<li>LoadPicker</li>
<li>LocalityBasedPicker</li>
</ol>
<p><a href="http://c.biancheng.net/view/6539.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6539.html</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ol>
<li>HBase 是分布式的非关系型数据库，支持多版本数据存储。容量大，支持百亿行，百万列的数据存储。</li>
<li>HBase 不支持事务，但是支持单条数据强一致性的读写。</li>
<li>HBase 中，表的所有行都是按照 RowKey 的字典序排列的，表在行的方向上分割为多个分区（Region）。</li>
<li>HBase 自动分片技术是通过 Region 的自动拆分、合并实现的，数据的读写都需要定位对应的 Region。</li>
<li>HBase 通过预写日志 WAL (Write Ahead Log) 保证 Region 故障恢复，Region 共用一个 HLog 文件。</li>
<li>HBase 底层是基于 LSM-tree 实现，所以 HBase 的写过程是先写 HLog 和 MemStore，再刷新到磁盘。读过程是先查询 Memtore 是否存在，不存在再检索磁盘。</li>
<li>LSM-tree 使得 HBase 实现了批量数据写入磁盘，大大提高数据写入性能。但是数据存储被拆分成了两个部分，一部分保存在磁盘、另一部分缓存在内存，不得不牺牲一部分读性能。</li>
<li>为了提升查询效率，HBase 使用了 BloomFilter 缩减查询范围，同时对 storefile 进行合并，减少磁盘寻址次数。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><font color="#009100">参考文档</font></tr></table></h1><p><a href="https://hbase.apache.org/book.html#regionserver.offheap.overview" target="_blank" rel="noopener">https://hbase.apache.org/book.html#regionserver.offheap.overview</a><br><a href="http://c.biancheng.net/view/6499.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6499.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Sort</title>
    <url>/2020/02/11/algorithm/quick-sort/</url>
    <content><![CDATA[<h1 id="快速排序实现思路"><a href="#快速排序实现思路" class="headerlink" title="快速排序实现思路"></a><table><tr><font color="#009100">快速排序实现思路</font></tr></table></h1><ol>
<li>在要排序的数组中，选择一个基准元素（通常是第一个或者是最后一个元素）;</li>
<li>通过扫描把序列分为两个部分，一部分比基准元素小，另一部分比基准元素大，此时基准元素在排好序的位置;</li>
<li>重复上述步骤，直到完全排好序。</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><table><tr><font color="#009100">代码实现</font></tr></table></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;length - i -<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                tmp = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="keyword">false</span>;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - j; i++) &#123;                                       </span><br><span class="line">              <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;                          </span><br><span class="line">                    tmp = arr[i];</span><br><span class="line">                    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                    arr[i + <span class="number">1</span>] = tmp;</span><br><span class="line">                    swapped = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;                </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif" alt="动画效果"></p>
<p><a href="http://www.jsons.cn/sort/" target="_blank" rel="noopener">动画演示</a></p>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><table><tr><font color="#009100">复杂度分析</font></tr></table></h1><p>最好的情况下（完全正序）复杂度是 O(1)；最糟糕的情况下（完全倒序），复杂度是 O(n^2)</p>
<h1 id="参阅文档"><a href="#参阅文档" class="headerlink" title="参阅文档"></a><table><tr><font color="#009100">参阅文档</font></tr></table></h1><p><a href="https://www.programcreek.com/2012/11/quicksort-array-in-java/" target="_blank" rel="noopener">https://www.programcreek.com/2012/11/quicksort-array-in-java/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>quick</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashSet 源码</title>
    <url>/2020/02/10/list/linkedhashset/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ul>
<li>LinkedHashSet 底层存储？</li>
<li>LinkedHashSet 和 HashSet 的区别？</li>
<li>LinkedHashSet 有序吗？</li>
<li>LinkedHashSet 支持按照访问顺序对元素排序吗？</li>
</ul>
<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><table><tr><font color="#009100">概括</font></tr></table></h1><p>LinkedHashSet 是 Set 接口的实现类，底层数据结构基于链表和哈希表，哈希表保证元素唯一，链表保证插入顺序。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/linkedhashset/linkedhashset.png" alt="LinkedHashSet 继承结构"></p>
<ul>
<li>实现 Set 接口，有 Set 所有特性</li>
<li>继承 HashSet ，拥有 HashSet 的特性</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity the initial capacity of the linked hash set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor      the load factor of the linked hash set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException  if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *               than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the LinkedHashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *              than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set with the default initial</span></span><br><span class="line"><span class="comment"> * capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new linked hash set with the same elements as the</span></span><br><span class="line"><span class="comment"> * specified collection.  The linked hash set is created with an initial</span></span><br><span class="line"><span class="comment"> * capacity sufficient to hold the elements in the specified collection</span></span><br><span class="line"><span class="comment"> * and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c  the collection whose elements are to be placed into</span></span><br><span class="line"><span class="comment"> *           this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>所有构造方法都调用了同一个父类的构造方法；</li>
<li>如果传入初始容量，则根据初始容量计算合适的容量；否则初始容量为 16；</li>
<li>如果传入加载因子，使用传入的加载因子；否则默认 0.75；</li>
</ul>
<p>上述的构造方法，都调用了同一个父类构造方法。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set.  (This package private</span></span><br><span class="line"><span class="comment"> * constructor is only used by LinkedHashSet.) The backing</span></span><br><span class="line"><span class="comment"> * HashMap instance is a LinkedHashMap with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dummy             ignored (distinguishes this</span></span><br><span class="line"><span class="comment"> *             constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>LinkedHashSet 继承自 HashSet，对元素的操作都是使用 HashSet 方法实现；</li>
<li>LinkedHaseSet 使用 LinkedHashMap 存储元素；</li>
</ul>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the specified initial capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>LinkedHashSet 的构造方法，最终调用了 LinkedHashMap 中的构造方法；</li>
<li>accessOrder 默认为 false，指定按照插入顺序排序；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>LinedHashSet 使用 LinkedHashMap 存储元素；</li>
<li>LinkedHashSet 是有序的，按照插入顺序排序；</li>
<li>LinkedHashSet 不支持按照访问顺序排序；</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedHashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>IdentityHashMap 源码</title>
    <url>/2020/02/10/list/identityhashmap/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><ul>
<li>IdentityHashMap 使用 hash 表存储数据，实现了 Map 接口。</li>
<li>与 HashMap 不同的是，IdentityHashMap 使用 <code>引用相等</code> 替换 <code>对象相等</code>；<blockquote>
<p>也就是说，IdentityHashMap 判断两个 key 相等的方式是 <code>(k1==k2)</code>，<br>而 HashMap 判断两个 key 相等的方式是 <code>(k1==null ? k2==null : k1.equals(k2))</code>；</p>
</blockquote>
</li>
</ul>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/identityhashmap/identityhashmap.png" alt="IdentityHashMap继承结构"></p>
<ul>
<li>实现了 Map 接口，拥有 Map 特性；</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The initial capacity used by the no-args constructor.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two.  The value 32 corresponds to the</span></span><br><span class="line"><span class="comment"> * (specified) expected maximum size of 21, given a load factor</span></span><br><span class="line"><span class="comment"> * of 2/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The minimum capacity, used if a lower value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.  The value 4 corresponds</span></span><br><span class="line"><span class="comment"> * to an expected maximum size of 2, given a load factor of 2/3.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_CAPACITY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;29.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In fact, the map can hold no more than MAXIMUM_CAPACITY-1 items</span></span><br><span class="line"><span class="comment"> * because it has to have at least one slot with the key == null</span></span><br><span class="line"><span class="comment"> * in order to avoid infinite loops in get(), put(), remove()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] table; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this identity hash map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of modifications, to support fast-fail iterators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Value representing null keys inside tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use NULL_KEY for key if it is null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span> ? NULL_KEY : key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns internal representation of null key back to caller as null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == NULL_KEY ? <span class="keyword">null</span> : key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>默认容量：32</li>
<li>最小容量：4</li>
<li>最大容量为：1 &lt;&lt; 29<blockquote>
<p>这里小于 MAXIMUM_CAPACITY-1，是因为它必须有一个 key 等于 null 的位置，<br>为了避免 get,put,remove 方法进入无限循环</p>
</blockquote>
</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty identity hash map with a default expected</span></span><br><span class="line"><span class="comment"> * maximum size (21).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty map with the specified expected maximum size.</span></span><br><span class="line"><span class="comment"> * Putting more than the expected number of key-value mappings into</span></span><br><span class="line"><span class="comment"> * the map may cause the internal data structure to grow, which may be</span></span><br><span class="line"><span class="comment"> * somewhat time-consuming.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedMaxSize the expected maximum size of the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &lt;tt&gt;expectedMaxSize&lt;/tt&gt; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expectedMaxSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expectedMaxSize is negative: "</span></span><br><span class="line">                                           + expectedMaxSize);</span><br><span class="line">    init(capacity(expectedMaxSize));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the appropriate capacity for the given expected maximum size.</span></span><br><span class="line"><span class="comment"> * Returns the smallest power of two between MINIMUM_CAPACITY and</span></span><br><span class="line"><span class="comment"> * MAXIMUM_CAPACITY, inclusive, that is greater than (3 *</span></span><br><span class="line"><span class="comment"> * expectedMaxSize)/2, if such a number exists.  Otherwise returns</span></span><br><span class="line"><span class="comment"> * MAXIMUM_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert expectedMaxSize &gt;= 0;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (expectedMaxSize &gt; MAXIMUM_CAPACITY / <span class="number">3</span>) ? MAXIMUM_CAPACITY :</span><br><span class="line">        (expectedMaxSize &lt;= <span class="number">2</span> * MINIMUM_CAPACITY / <span class="number">3</span>) ? MINIMUM_CAPACITY :</span><br><span class="line">        Integer.highestOneBit(expectedMaxSize + (expectedMaxSize &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new identity hash map containing the keys-value mappings</span></span><br><span class="line"><span class="comment"> * in the specified map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map whose mappings are to be placed into this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allow for a bit of growth</span></span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">int</span>) ((<span class="number">1</span> + m.size()) * <span class="number">1.1</span>));</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>没有指定初始容量，则使用默认的初始容量：32；</li>
<li>指定期望的初始容量，使用大于期望容量最小 2 的 n 次幂；</li>
</ul>
<h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this identity</span></span><br><span class="line"><span class="comment"> * hash map.  If the map previously contained a mapping for the key, the</span></span><br><span class="line"><span class="comment"> * old value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #get(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #containsKey(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object k = maskNull(key);</span><br><span class="line"></span><br><span class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] tab = table;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">                tab[i + <span class="number">1</span>] = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Use optimized form of 3 * s.</span></span><br><span class="line">        <span class="comment">// Next capacity is len, 2 * current capacity.</span></span><br><span class="line">        <span class="comment">// 如果3*size 大于数组的length，则进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len))</span><br><span class="line">            <span class="keyword">continue</span> retryAfterResize;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        tab[i] = k;</span><br><span class="line">        tab[i + <span class="number">1</span>] = value;</span><br><span class="line">        size = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for Object x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = System.identityHashCode(x);</span><br><span class="line">    <span class="comment">// Multiply by -127, and left-shift to use least bit as part of hash</span></span><br><span class="line">    <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>put 的时候先通过引用是否相等判断key是不是已经在表中存在，如果存在更新 oldValue 为新的 value，如果元素个数达到阈值，扩容处理，然后再找合适的位置放置 key 和 value；</li>
<li>在数组的i索引处存key，而紧挨着 i 的 i+1 处存 value，并且由于 hash 方法的原因，key 所对应的 index 全是偶数，自然 i+1 就是奇数了。这也说明了另一点，数组初始化的时候，数组的长度被定义为默认容量的 2 倍，因为数组元素的每次保存是都占了数组的两个位置。</li>
<li>put 的扩容条件是当存放的数组达到数组长度的 1/3 的时候，就需要扩容。</li>
<li>System.identityHashCode(x) 是取地址值进行计算；</li>
</ul>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key == k)&#125;,</span></span><br><span class="line"><span class="comment"> * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k)</span><br><span class="line">            <span class="keyword">return</span> (V) tab[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// hash 冲突，移位遍历</span></span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Circularly traverses table of size len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<ul>
<li>如果 i 处找到 key，说明 i+1 处就是索引对应的 value；</li>
<li>如果 i 处找到的 key 值和传入的 key 不相等，说明 hash 冲突，移动 2 个位置继续查找；</li>
</ul>
<h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping for this key from this map if present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>删除方法与查找方法类似，找到则置空，释放空间；</li>
</ul>
<h2 id="resize-int-newCapacity"><a href="#resize-int-newCapacity" class="headerlink" title="resize(int newCapacity)"></a>resize(int newCapacity)</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resizes the table if necessary to hold given capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newCapacity the new capacity, must be a power of two.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether a resize did in fact take place</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert (newCapacity &amp; -newCapacity) == newCapacity; // power of 2</span></span><br><span class="line">    <span class="keyword">int</span> newLength = newCapacity * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Object[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldLength = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldLength == <span class="number">2</span> * MAXIMUM_CAPACITY) &#123; <span class="comment">// can't expand any further</span></span><br><span class="line">        <span class="keyword">if</span> (size == MAXIMUM_CAPACITY - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Capacity exhausted."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldLength &gt;= newLength)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Object[] newTable = <span class="keyword">new</span> Object[newLength];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLength; j += <span class="number">2</span>) &#123;</span><br><span class="line">        Object key = oldTable[j];</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object value = oldTable[j+<span class="number">1</span>];</span><br><span class="line">            oldTable[j] = <span class="keyword">null</span>;</span><br><span class="line">            oldTable[j+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> i = hash(key, newLength);</span><br><span class="line">            <span class="keyword">while</span> (newTable[i] != <span class="keyword">null</span>)</span><br><span class="line">                i = nextKeyIndex(i, newLength);</span><br><span class="line">            newTable[i] = key;</span><br><span class="line">            newTable[i + <span class="number">1</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>扩容的数组是原来的两倍；</li>
</ul>
<h2 id="hashCode-amp-equals-Object-o"><a href="#hashCode-amp-equals-Object-o" class="headerlink" title="hashCode() &amp; equals(Object o)"></a>hashCode() &amp; equals(Object o)</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the hash code value for this map.  The hash code of a map is</span></span><br><span class="line"><span class="comment"> * defined to be the sum of the hash codes of each entry in the map's</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;entrySet()&lt;/tt&gt; view.  This ensures that &lt;tt&gt;m1.equals(m2)&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * implies that &lt;tt&gt;m1.hashCode()==m2.hashCode()&lt;/tt&gt; for any two</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instances &lt;tt&gt;m1&lt;/tt&gt; and &lt;tt&gt;m2&lt;/tt&gt;, as</span></span><br><span class="line"><span class="comment"> * required by the general contract of &#123;<span class="doctag">@link</span> Object#hashCode&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Map.Entry&lt;/tt&gt; instances in the set returned by this map's</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;entrySet&lt;/tt&gt; method, it is possible that the contractual</span></span><br><span class="line"><span class="comment"> * requirement of &lt;tt&gt;Object.hashCode&lt;/tt&gt; mentioned in the previous</span></span><br><span class="line"><span class="comment"> * paragraph will be violated if one of the two objects being compared is</span></span><br><span class="line"><span class="comment"> * an &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instance and the other is a normal map.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the hash code value for this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Object#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #equals(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i +=<span class="number">2</span>) &#123;</span><br><span class="line">        Object key = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object k = unmaskNull(key);</span><br><span class="line">            result += System.identityHashCode(k) ^</span><br><span class="line">                      System.identityHashCode(tab[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compares the specified object with this map for equality.  Returns</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map and the two maps</span></span><br><span class="line"><span class="comment"> * represent identical object-reference mappings.  More formally, this</span></span><br><span class="line"><span class="comment"> * map is equal to another map &lt;tt&gt;m&lt;/tt&gt; if and only if</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;this.entrySet().equals(m.entrySet())&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of this map it is</span></span><br><span class="line"><span class="comment"> * possible that the symmetry and transitivity requirements of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Object.equals&lt;/tt&gt; contract may be violated if this map is compared</span></span><br><span class="line"><span class="comment"> * to a normal map.  However, the &lt;tt&gt;Object.equals&lt;/tt&gt; contract is</span></span><br><span class="line"><span class="comment"> * guaranteed to hold among &lt;tt&gt;IdentityHashMap&lt;/tt&gt; instances.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  o object to be compared for equality with this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Object#equals(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IdentityHashMap) &#123;</span><br><span class="line">        IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (m.size() != size)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Object[] tab = m.table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            Object k = tab[i];</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span> &amp;&amp; !containsMapping(k, tab[i + <span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> entrySet().equals(m.entrySet());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// o is not a Map</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>IdentityHashMap 重写了 equals 和 hashcode 方法，通过 System.identityHashCode 方法来实现的 hashCode ，确保使用地址值来判断；</li>
<li>通过重写 equals 方法，判定只有 key 值全等情况下才会判断 value 值相等；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>IdentityHashMap 的实现不同于 HashMap，虽然也是数组，不过 IdentityHashMap 中没有用到链表，解决冲突的方式是计算下一个有效索引，并且将数据 key 和 value 紧挨着存在map中，即 table[i]=key，那么 table[i+1]=value。</li>
<li>IdentityHashMap 的 hash 的计算没有使用 Object 的 hashCode 方法，而是使用的 System.identityHashCode 方法，这是根据对象的内存地址来计算散列码。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IdentityHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap 源码</title>
    <url>/2020/02/10/list/treemap/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ol>
<li>如何用 TreeMap 实现一致性 Hash ？</li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><ul>
<li>TreeMap 存储K-V键值对，通过红黑树（R-B tree）实现；</li>
<li>红黑树结构天然支持排序，默认情况下通过Key值的自然顺序进行排序；</li>
</ul>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/treemap/treemap.png" alt="TreeMap继承结构"></p>
<ul>
<li>实现了 SortedMap 接口<blockquote>
<p>可以按key的大小来遍历</p>
</blockquote>
</li>
<li>实现了 NavigableMap 接口<blockquote>
<p>可查询一些离目标key最近的元素的方法</p>
</blockquote>
</li>
</ul>
<p>TreeMap 使用红黑树的存储结构，时间复杂度为 O(log n)，</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><table><tr><font color="#009100">红黑树</font></tr></table></h1><p><img src="/2020/02/10/list/treemap/rb_tree.png" alt="红黑树"></p>
<p><strong>红黑树规则：</strong></p>
<ul>
<li>节点分为红色或者黑色；</li>
<li>根节点必为黑色；</li>
<li>叶子节点都为黑色，且为null；</li>
<li>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</li>
<li>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</li>
<li>新加入到红黑树的节点为红色节点；</li>
</ul>
<p><strong>红黑树自平衡基本操作：</strong></p>
<ul>
<li>变色：在不违反上述红黑树规则特点情况下，将红黑树某个node节点颜色由红变黑，或者由黑变红；</li>
<li>左旋：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点；</li>
<li>右旋：顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点；</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The comparator used to maintain order in this tree map, or</span></span><br><span class="line"><span class="comment"> * null if it uses the natural ordering of its keys.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of entries in the tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><p>两种比较器的使用</p>
<blockquote>
<ol>
<li>Key 实现了 Commparator 接口；</li>
<li>通过构造方法传入比较器；</li>
</ol>
</blockquote>
</li>
<li><p>根节点</p>
<blockquote>
<p> 树的根节点，所有的树都存储在一棵树；</p>
</blockquote>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>红黑树结构。</p>
<details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Node in the Tree.  Doubles as a means to pass key-value pairs back to</span></span><br><span class="line"><span class="comment"> * user (see Map.Entry).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>Entry 的实现结构：</p>
<p><img src="/2020/02/10/list/treemap/entry.png" alt="Entry结构"></p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree map, using the natural ordering of its</span></span><br><span class="line"><span class="comment"> * keys.  All keys inserted into the map must implement the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Comparable&#125; interface.  Furthermore, all such keys must be</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;mutually comparable&lt;/em&gt;: &#123;<span class="doctag">@code</span> k1.compareTo(k2)&#125; must not throw</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys &#123;<span class="doctag">@code</span> k1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k2&#125; in the map.  If the user attempts to put a key into the</span></span><br><span class="line"><span class="comment"> * map that violates this constraint (for example, the user attempts to</span></span><br><span class="line"><span class="comment"> * put a string key into a map whose keys are integers), the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> put(Object key, Object value)&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree map, ordered according to the given</span></span><br><span class="line"><span class="comment"> * comparator.  All keys inserted into the map must be &lt;em&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/em&gt; by the given comparator: &#123;<span class="doctag">@code</span> comparator.compare(k1,</span></span><br><span class="line"><span class="comment"> * k2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k1&#125; and &#123;<span class="doctag">@code</span> k2&#125; in the map.  If the user attempts to put</span></span><br><span class="line"><span class="comment"> * a key into the map that violates this constraint, the &#123;<span class="doctag">@code</span> put(Object</span></span><br><span class="line"><span class="comment"> * key, Object value)&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this map.</span></span><br><span class="line"><span class="comment"> *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment"> *        ordering&#125; of the keys will be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree map containing the same mappings as the given</span></span><br><span class="line"><span class="comment"> * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys.</span></span><br><span class="line"><span class="comment"> * All keys inserted into the new map must implement the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Comparable&#125; interface.  Furthermore, all such keys must be</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;mutually comparable&lt;/em&gt;: &#123;<span class="doctag">@code</span> k1.compareTo(k2)&#125; must not throw</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys &#123;<span class="doctag">@code</span> k1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k2&#125; in the map.  This method runs in n*log(n) time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the keys in m are not &#123;<span class="doctag">@link</span> Comparable&#125;,</span></span><br><span class="line"><span class="comment"> *         or are not mutually comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree map containing the same mappings and</span></span><br><span class="line"><span class="comment"> * using the same ordering as the specified sorted map.  This</span></span><br><span class="line"><span class="comment"> * method runs in linear time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  m the sorted map whose mappings are to be placed in this map,</span></span><br><span class="line"><span class="comment"> *         and whose comparator is to be used to sort this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><strong><em>两种比较器</em></strong></p>
<ul>
<li>传入定义的 Comparator 比较器；</li>
<li>Key 实现 Comparable 接口；</li>
</ul>
<h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><details>
<summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> key&#125; compares</span></span><br><span class="line"><span class="comment"> * equal to &#123;<span class="doctag">@code</span> k&#125; according to the map's ordering, then this</span></span><br><span class="line"><span class="comment"> * method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;em&gt;necessarily&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the specified key cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the keys currently in the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment"> *         and this map uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null keys</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns this map's entry for the given key, or &#123;<span class="doctag">@code</span> null&#125; if the map</span></span><br><span class="line"><span class="comment"> * does not contain an entry for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this map's entry for the given key, or &#123;<span class="doctag">@code</span> null&#125; if the map</span></span><br><span class="line"><span class="comment"> *         does not contain an entry for the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the specified key cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the keys currently in the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment"> *         and this map uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null keys</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将key强转为Comparable</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 小于0，从左子树查找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 大于0，从右子树查找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果相等，则返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry using comparator. Split off from getEntry</span></span><br><span class="line"><span class="comment"> * for performance. (This is not worth doing for most methods,</span></span><br><span class="line"><span class="comment"> * that are less dependent on comparator performance, but is</span></span><br><span class="line"><span class="comment"> * worthwhile here.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 小于0，从左子树查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 大于0，从右子树查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 相等，则返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><strong>二分查找的思想：</strong></p>
<ul>
<li>从root遍历整个树；</li>
<li>如果待查找的 key 比当前遍历的 key 小，则在其左子树中查找；</li>
<li>如果待查找的 key 比当前遍历的 key 大，则在其右子树中查找；</li>
<li>如果待查找的 key 与当前遍历的 key 相等，则找到了该元素，直接返回；</li>
</ul>
<h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the specified key cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the keys currently in the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment"> *         and this map uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null keys</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有根节点，直接插入根节点</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        </span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 比较的结果</span></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用构造方法设置的比较器</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 左子树查找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 右子树查找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 节点已存在并替换</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 key 实现的比较器</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 左子树查找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 右子树查找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 节点已存在并替换</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素后做平衡</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；</li>
<li>插入的元素的父节点如果为黑色，不需要平衡；</li>
<li>插入的元素的父节点如果为红色，则做需要平衡，源码通过 fixAfterInsertion(e) 方法进行自平衡；</li>
</ul>
<h2 id="fixAfterInsertion-Entry-lt-K-V-gt-x"><a href="#fixAfterInsertion-Entry-lt-K-V-gt-x" class="headerlink" title="fixAfterInsertion(Entry&lt;K,V&gt; x)"></a>fixAfterInsertion(Entry&lt;K,V&gt; x)</h2><p>插入后再平衡。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红色节点，做旋转</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// a）如果父节点是祖父节点的左节点</span></span><br><span class="line">            <span class="comment">// y为叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1）如果叔叔节点为红色  </span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将叔叔节点设为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// （3）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （4）将祖父节点设为新的当前节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                <span class="comment">// 情况2）如果当前节点为其父节点的右节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// （1）将父节点设为当前节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">// （2）以新当前节点左旋</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3）如果当前节点为其父节点的左节点（如果是情况2）则左旋之后新当前节点正好为其父节点的左节点了）</span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （3）以祖父节点为支点进行右旋</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b）如果父节点是祖父节点的右节点</span></span><br><span class="line">            <span class="comment">// y是叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1）如果叔叔节点为红色</span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将叔叔节点设为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// （3）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （4）将祖父节点设为新的当前节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                <span class="comment">// 情况2）如果当前节点为其父节点的左节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// （1）将父节点设为当前节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">// （2）以新当前节点右旋</span></span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 情况3）如果当前节点为其父节点的右节点（如果是情况2）则右旋之后新当前节点正好为其父节点的右节点了）</span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （3）以祖父节点为支点进行左旋</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 黑色节点，不必再做旋转</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>fixAfterInsertion(Entry&lt;K,V&gt; x) 进行自平衡处理，以下是红黑树处理逻辑：</p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">无需调整</th>
<th align="center">只需【变色】</th>
<th align="center">【旋转 + 变色】</th>
</tr>
</thead>
<tbody><tr>
<td align="center">场景1</td>
<td align="center">父节点为黑色时，插入子节点（默认插入节点为红色）</td>
<td align="center">空树插入根节点，将根节点红色变为黑色</td>
<td align="center">父节点为红色左节点，叔父节点为黑色，插入左子节点，那么通过【左左节点旋转】</td>
</tr>
<tr>
<td align="center">场景2</td>
<td align="center">-</td>
<td align="center">父节点和叔父节点都为红色</td>
<td align="center">父节点为红色左节点，叔父节点为黑色，插入右子节点，那么通过【左右节点旋转】</td>
</tr>
<tr>
<td align="center">场景3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">父节点为红色右节点，叔父节点为黑色，插入左子节点，那么通过【右左节点旋转】</td>
</tr>
<tr>
<td align="center">场景4</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">父节点为红色右节点，叔父节点为黑色，插入右子节点，那么通过【右右节点旋转】</td>
</tr>
</tbody></table>
<p><a href="https://www.cnblogs.com/LiaHon/p/11203229.html" target="_blank" rel="noopener">红黑树参考文档</a></p>
<p>如果符合再平衡的条件 (父节点为红色)，分六种情况处理：</p>
<p><strong>父节点为祖父节点的左节点</strong></p>
<ul>
<li><p>父节点为红色，叔父节点也为红色（场景一）</p>
<blockquote>
<ol>
<li>将父节点设为黑色</li>
<li>将叔父节点设为黑色</li>
<li>将祖父节点设为红色</li>
<li>将祖父节点设为新的当前节点</li>
</ol>
</blockquote>
</li>
<li><p>父节点为红色，叔父节点也为黑色，且当前节点是其父节点的右节点（场景二）</p>
<blockquote>
<ol>
<li>将父节点设为当前节点</li>
<li>以新当前节点左旋</li>
<li>此时进入（场景三）</li>
</ol>
</blockquote>
</li>
<li><p>父节点为红色，叔父节点也为黑色，且当前节点是其父节点的左节点（场景三）</p>
<blockquote>
<ol>
<li>将父节点设为黑色</li>
<li>将祖父节点设为红色</li>
<li>以祖父节点为支点进行右旋</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>父节点为祖父节点的右节点</strong></p>
<ul>
<li><p>父节点为红色，叔父节点也为红色（场景四）</p>
<blockquote>
<ol>
<li>将父节点设为黑色</li>
<li>将叔父节点设为黑色</li>
<li>将祖父节点设为红色</li>
<li>将祖父节点设为新的当前节点</li>
</ol>
</blockquote>
</li>
<li><p>父节点为红色，叔父节点也为黑色，且当前节点是其父节点的右节点（场景五）</p>
<blockquote>
<ol>
<li>将父节点设为当前节点</li>
<li>以新当前节点右旋</li>
<li>此时进入（场景六）</li>
</ol>
</blockquote>
</li>
<li><p>父节点为红色，叔父节点也为黑色，且当前节点是其父节点的左节点（场景六）</p>
<blockquote>
<ol>
<li>将父节点设为黑色</li>
<li>将祖父节点设为红色</li>
<li>以祖父节点为支点进行左旋</li>
</ol>
</blockquote>
</li>
</ul>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noopener">红黑树动画演示</a></p>
<h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping for this key from this TreeMap if present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key key for which mapping should be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the specified key cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the keys currently in the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment"> *         and this map uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null keys</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    <span class="comment">// 节点删除方法</span></span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete node p, and then rebalance the tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line">    <span class="comment">// point to successor.</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点既有左子节点，又有右子节点</span></span><br><span class="line">        <span class="comment">// 取其右子树中最小的节点</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        <span class="comment">// 用右子树中最小节点的值替换当前节点的值</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        <span class="comment">// 把右子树中最小节点设为当前节点</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        <span class="comment">// 把替换节点直接放到当前节点的位置上（相当于删除了p，并把替换节点移动过来了）</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平衡后删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>如果删除的位置有两个叶子节点，则从其右子树中取最小的元素放到删除的位置，然后把删除位置移到替代元素的位置，进入下一步。</li>
<li>如果删除的位置只有一个叶子节点（有可能是经过第一步转换后的删除位置），则把那个叶子节点作为替代元素，放到删除的位置，然后把这个叶子节点删除。</li>
<li>如果删除的位置没有叶子节点，则直接把这个删除位置的元素删除。</li>
<li>针对红黑树，如果删除位置是黑色节点，还需要做再平衡。</li>
<li>如果有替代元素，则以替代元素作为当前节点进入再平衡。</li>
<li>如果没有替代元素，则以删除的位置的元素作为当前节点进入再平衡，平衡之后再删除这个节点。</li>
</ul>
<h2 id="fixAfterDeletion-Entry-lt-K-V-gt-x"><a href="#fixAfterDeletion-Entry-lt-K-V-gt-x" class="headerlink" title="fixAfterDeletion(Entry&lt;K,V&gt; x)"></a>fixAfterDeletion(Entry&lt;K,V&gt; x)</h2><p>删除元素后再平衡。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点是黑色，做平衡</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            <span class="comment">// 当前节点是父节点的左子节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// 左旋</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                <span class="comment">// 更新兄弟节点</span></span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 兄弟节点的两个子节点都是黑色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// 重置当前节点</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点的右节点是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// 右旋转</span></span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                <span class="comment">// 左旋转</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="comment">// 当前节点是父节点的右子节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 兄弟节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// 右旋转</span></span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 兄弟节点的子节点都是黑色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// 重置当前节点</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 兄弟节点的左节点是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// 左旋转</span></span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    <span class="comment">// 重置兄弟节点</span></span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                <span class="comment">// 右旋转</span></span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>真正删除的肯定是黑色节点才会进入到再平衡阶段。</li>
<li>因为删除的是黑色节点，导致整颗树不平衡了，所以这里我们假设把删除的黑色赋予当前节点，这样当前节点除了它自已的颜色还多了一个黑色；<blockquote>
<ol>
<li>如果当前节点是根节点，则直接设置为黑色，不需要再平衡；</li>
<li>如果当前节点是红节点，则直接设置为黑色，不需要平衡；</li>
<li>如果当前节点是黑节点，</li>
<li>如果当前节点是黑节点，则我们要通过旋转把这个多出来的黑色不断的向上传递到一个红色节点</li>
</ol>
</blockquote>
</li>
</ul>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noopener">红黑树动画演示</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>TreeMap 的存储结构是一棵红黑树；</li>
<li>TreeMap 中的元素是有序的，按 key 的顺序排列；</li>
<li>TreeMap 可以按照范围查找元素；</li>
</ul>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><table><tr><font color="#009100">小知识</font></tr></table></h1><h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>左旋：</strong></p>
<p>逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点</p>
<p><strong>左旋操作步骤如下：</strong></p>
<p>首先断开节点PL与右子节点G的关系，同时将其右子节点的引用指向节点C2；然后断开节点G与左子节点C2的关系，同时将G的左子节点的应用指向节点PL</p>
<p><img src="/2020/02/10/list/treemap/rotateLeft.png" alt="左旋"></p>
<h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** From CLR */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>右旋：</strong></p>
<p>顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点</p>
<p><strong>右旋操作步骤如下：</strong></p>
<p>首先断开节点G与左子节点PL的关系，同时将其左子节点的引用指向节点C2；然后断开节点PL与右子节点C2的关系，同时将PL的右子节点的应用指向节点G</p>
<p><img src="/2020/02/10/list/treemap/rotateRight.png" alt="右旋"></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化</a><br><a href="https://www.cnblogs.com/LiaHon/p/11203229.html" target="_blank" rel="noopener">红黑树原理</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeSet 源码</title>
    <url>/2020/02/10/list/treeset/</url>
    <content><![CDATA[<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><table><tr><font color="#009100">概括</font></tr></table></h1><p>TreeSet 是一个有序集合，底层采用 TreeMap 实现，非线程安全。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/treeset/treeset.png" alt="TreeSet继承结构"></p>
<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The backing map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><p>NavigableMap</p>
<blockquote>
<p>TreeSet 底层使用NavigableMap存储元素</p>
</blockquote>
</li>
<li><p>PRESENT</p>
<blockquote>
<p>虚拟元素, 用来作为 value 存储在 map 中</p>
</blockquote>
</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a set backed by the specified navigable map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree set, sorted according to the</span></span><br><span class="line"><span class="comment"> * natural ordering of its elements.  All elements inserted into</span></span><br><span class="line"><span class="comment"> * the set must implement the &#123;<span class="doctag">@link</span> Comparable&#125; interface.</span></span><br><span class="line"><span class="comment"> * Furthermore, all such elements must be &lt;i&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/i&gt;: &#123;<span class="doctag">@code</span> e1.compareTo(e2)&#125; must not throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements &#123;<span class="doctag">@code</span> e1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add an element</span></span><br><span class="line"><span class="comment"> * to the set that violates this constraint (for example, the user</span></span><br><span class="line"><span class="comment"> * attempts to add a string element to a set whose elements are</span></span><br><span class="line"><span class="comment"> * integers), the &#123;<span class="doctag">@code</span> add&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree set, sorted according to the specified</span></span><br><span class="line"><span class="comment"> * comparator.  All elements inserted into the set must be &lt;i&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/i&gt; by the specified comparator: &#123;<span class="doctag">@code</span> comparator.compare(e1,</span></span><br><span class="line"><span class="comment"> * e2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e1&#125; and &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add</span></span><br><span class="line"><span class="comment"> * an element to the set that violates this constraint, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> add&#125; call will throw a &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this set.</span></span><br><span class="line"><span class="comment"> *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment"> *        ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection, sorted according to the &lt;i&gt;natural ordering&lt;/i&gt; of its</span></span><br><span class="line"><span class="comment"> * elements.  All elements inserted into the set must implement the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Comparable&#125; interface.  Furthermore, all such elements must be</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;mutually comparable&lt;/i&gt;: &#123;<span class="doctag">@code</span> e1.compareTo(e2)&#125; must not throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements &#123;<span class="doctag">@code</span> e1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e2&#125; in the set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection whose elements will comprise the new set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the elements in &#123;<span class="doctag">@code</span> c&#125; are</span></span><br><span class="line"><span class="comment"> *         not &#123;<span class="doctag">@link</span> Comparable&#125;, or are not mutually comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree set containing the same elements and</span></span><br><span class="line"><span class="comment"> * using the same ordering as the specified sorted set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s sorted set whose elements will comprise the new set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified sorted set is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>TreeSet 可指定具体的存储，只要是实现 <code>NavigableMap</code> ；</li>
<li>TreeSet 默认使用 <code>TreeMap</code> 存储；</li>
</ul>
<h2 id="其他操作方法"><a href="#其他操作方法" class="headerlink" title="其他操作方法"></a>其他操作方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &#123;<span class="doctag">@code</span> e&#125; to this set if</span></span><br><span class="line"><span class="comment"> * the set contains no element &#123;<span class="doctag">@code</span> e2&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> *         element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the specified object cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the elements currently in this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the specified element from this set if it is present.</span></span><br><span class="line"><span class="comment"> * More formally, removes an element &#123;<span class="doctag">@code</span> e&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * if this set contains such an element.  Returns &#123;<span class="doctag">@code</span> true&#125; if</span></span><br><span class="line"><span class="comment"> * this set contained the element (or equivalently, if this set</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).  (This set will not contain the</span></span><br><span class="line"><span class="comment"> * element once the call returns.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o object to be removed from this set, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this set contained the specified element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the specified object cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the elements currently in this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this set.</span></span><br><span class="line"><span class="comment"> * The set will be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds all of the elements in the specified collection to this set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this set changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the elements provided cannot be compared</span></span><br><span class="line"><span class="comment"> *         with the elements currently in the set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null or</span></span><br><span class="line"><span class="comment"> *         if any element is null and this set uses natural ordering, or</span></span><br><span class="line"><span class="comment"> *         its comparator does not permit null elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">        Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">        <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            map.addAllForTreeSet(set, PRESENT);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> fromElement&#125; or &#123;<span class="doctag">@code</span> toElement&#125;</span></span><br><span class="line"><span class="comment"> *         is null and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                              E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class="line">                                   toElement,   toInclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> toElement&#125; is null and</span></span><br><span class="line"><span class="comment"> *         this set uses natural ordering, or its comparator does</span></span><br><span class="line"><span class="comment"> *         not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> fromElement&#125; is null and</span></span><br><span class="line"><span class="comment"> *         this set uses natural ordering, or its comparator does</span></span><br><span class="line"><span class="comment"> *         not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> fromElement&#125; or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> toElement&#125; is null and this set uses natural ordering,</span></span><br><span class="line"><span class="comment"> *         or its comparator does not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> toElement&#125; is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator does</span></span><br><span class="line"><span class="comment"> *         not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> headSet(toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> fromElement&#125; is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator does</span></span><br><span class="line"><span class="comment"> *         not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailSet(fromElement, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">    <span class="keyword">return</span> m.comparator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回最小的元素</span></span><br><span class="line">    <span class="keyword">return</span> m.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回最大的元素</span></span><br><span class="line">    <span class="keyword">return</span> m.lastKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NavigableSet API methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小于等于 e 的最大元素</span></span><br><span class="line">    <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小于等于 e 的最大元素</span></span><br><span class="line">    <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大于等于 e 的最小元素</span></span><br><span class="line">    <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> *         and this set uses natural ordering, or its comparator</span></span><br><span class="line"><span class="comment"> *         does not permit null elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 大于等于 e 的最小元素</span></span><br><span class="line">    <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小元素</span></span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大元素</span></span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &lt;em&gt;&lt;a href="Spliterator.html#binding"&gt;late-binding&lt;/a&gt;&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;<span class="doctag">@link</span> Spliterator&#125; over the elements in this</span></span><br><span class="line"><span class="comment"> * set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> Spliterator&#125; reports &#123;<span class="doctag">@link</span> Spliterator#SIZED&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Spliterator#DISTINCT&#125;, &#123;<span class="doctag">@link</span> Spliterator#SORTED&#125;, and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Spliterator#ORDERED&#125;.  Overriding implementations should document</span></span><br><span class="line"><span class="comment"> * the reporting of additional characteristic values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The spliterator's comparator (see</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.Spliterator#getComparator()&#125;) is &#123;<span class="doctag">@code</span> null&#125; if</span></span><br><span class="line"><span class="comment"> * the tree set's comparator (see &#123;<span class="doctag">@link</span> #comparator()&#125;) is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * Otherwise, the spliterator's comparator is the same as or imposes the</span></span><br><span class="line"><span class="comment"> * same total ordering as the tree set's comparator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Spliterator&#125; over the elements in this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分割迭代器</span></span><br><span class="line">    <span class="keyword">return</span> TreeMap.keySpliteratorFor(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>源码比较简单，基本都是调用 map 相应的方法，可根据 key 取最近的元素。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>TreeSet底层使用 NavigableMap 存储元素；</li>
<li>TreeSet是有序的；非线程安全的；</li>
<li>TreeSet实现了 NavigableSet 接口，而 NavigableSet 继承自 SortedSet 接口；</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><h2 id="TreeSet和LinkedHashSet都是有序的，那它们有何不同？"><a href="#TreeSet和LinkedHashSet都是有序的，那它们有何不同？" class="headerlink" title="TreeSet和LinkedHashSet都是有序的，那它们有何不同？"></a>TreeSet和LinkedHashSet都是有序的，那它们有何不同？</h2><blockquote>
<ul>
<li>LinkedHashSet 有序性主要依赖于 LinkedHashMap 的有序性，所以它的有序性是指按照插入顺序保证的有序性；<br>而 LinkedHashMap 维护了一个双向链表，实现元素顺序的控制；</li>
<li>TreeSet 实现了 SortedSet 接口，它的有序性主要依赖于 NavigableMap 的有序性，而 NavigableMap 又继承自 SortedMap；<br>这个接口的有序性是指按照 key 的自然排序保证的有序性，而key的自然排序又有两种实现方式，一种是key实现Comparable接口，一种是构造方法传入Comparator比较器。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>WeakHashMap</title>
    <url>/2020/02/10/list/weakhashmap/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><p>WeakHashMap 内部的 key 会存储为弱引用，当 JVM GC 的时候，如果这些 key 没有强引用存在的化，会被 GC 回收掉。<br>WeakHashMap 的存储结构是由 数组 + 链表 实现的。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/weakhashmap/weakhashmap.png" alt="WeakHashMap 继承结构"></p>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this weak hash map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>默认容量是 16，最大为 2^30；</li>
<li>装载因子为 0.75；</li>
<li>弱键失效，会把 Entry 添加到引用队列；</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty &lt;tt&gt;WeakHashMap&lt;/tt&gt; with the given initial</span></span><br><span class="line"><span class="comment"> * capacity and the given load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity The initial capacity of the &lt;tt&gt;WeakHashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      The load factor of the &lt;tt&gt;WeakHashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative,</span></span><br><span class="line"><span class="comment"> *         or if the load factor is nonpositive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Initial Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load factor: "</span>+</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    table = newTable(capacity);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The entries in this hash table extend WeakReference, using its main ref</span></span><br><span class="line"><span class="comment"> * field as the key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        K k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            V v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        K k = getKey();</span><br><span class="line">        V v = getValue();</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>与 HashMap 类似，初始容量为 2^n ；</li>
<li>扩容门槛为 <code>capacity * loadFactor</code></li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for this key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空值替换成空对象</span></span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="comment">// 计算存储位置</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">// 如果key存在，则修改</span></span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Value representing null keys inside tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use NULL_KEY for key if it is null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment"> * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment"> * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment"> * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment"> * in lower bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks for equality of non-null reference x and possibly-null y.  By</span></span><br><span class="line"><span class="comment"> * default uses Object.equals.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object x, Object y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == y || x.equals(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>计算hash；</li>
</ul>
<blockquote>
<p>HashMap 不同，HashMap 中如果key为空直接返回0，这里是用空对象来计算的。</p>
</blockquote>
<ul>
<li><p>计算在哪个桶中；</p>
</li>
<li><p>遍历桶对应的链表，如果找到元素就用新值替换旧值，并返回旧值；</p>
</li>
<li><p>如果没找到就在链表头部插入新元素；</p>
</li>
<li><p>如果元素数量达到了扩容门槛，就把容量扩大到2倍大小；</p>
</li>
</ul>
<blockquote>
<p>HashMap中是大于threshold才扩容，这里等于threshold就开始扩容了。</p>
</blockquote>
<h3 id="resize-int-newCapacity"><a href="#resize-int-newCapacity" class="headerlink" title="resize(int newCapacity)"></a>resize(int newCapacity)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment"> * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment"> * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment"> * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment"> *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment"> *        is irrelevant).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 最大容量不再扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立一个新数组，把旧数组的数据转移到新数组</span></span><br><span class="line">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class="line">    transfer(oldTable, newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If ignoring null elements and processing ref queue caused massive</span></span><br><span class="line"><span class="comment">     * shrinkage, then restore old table.  This should be rare, but avoids</span></span><br><span class="line"><span class="comment">     * unbounded expansion of garbage-filled tables.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 如果元素个数大于扩容门槛的一半，则使用新桶和新容量，并计算新的扩容门槛</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold / <span class="number">2</span>) &#123;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用旧数组，转移过程中会清除失效的 Entry</span></span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        transfer(newTable, oldTable);</span><br><span class="line">        table = oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Transfers all entries from src to dest tables */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        src[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object key = e.get();</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = <span class="keyword">null</span>;  <span class="comment">// Help GC</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">//  "   "</span></span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, dest.length);</span><br><span class="line">                e.next = dest[i];</span><br><span class="line">                dest[i] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><p>判断旧容量是否达到最大容量，达到最大容量，则不在进行扩容；</p>
</li>
<li><p>新建新数组并把元素全部转移到新桶中；</p>
</li>
<li><p>如果转移后元素个数不到扩容门槛的一半，则把元素再转移回旧数组，继续使用旧数组，说明不需要扩容；否则使用新数组，并计算新数组的扩容门槛；</p>
</li>
<li><p>转移元素的过程中会把key为null的元素清除掉，所以size会变小；</p>
</li>
</ul>
<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="comment">// 计算在数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>计算元素在数组中的位置</li>
<li>遍历链表，如果找到，则返回</li>
</ul>
<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping for a key from this weak hash map if it is present.</span></span><br><span class="line"><span class="comment"> * More formally, if this map contains a mapping from key &lt;tt&gt;k&lt;/tt&gt; to</span></span><br><span class="line"><span class="comment"> * value &lt;tt&gt;v&lt;/tt&gt; such that &lt;code&gt;(key==null ?  k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&lt;/code&gt;, that mapping is removed.  (The map can contain</span></span><br><span class="line"><span class="comment"> * at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Returns the value to which this map previously associated the key,</span></span><br><span class="line"><span class="comment"> * or &lt;tt&gt;null&lt;/tt&gt; if the map contained no mapping for the key.  A</span></span><br><span class="line"><span class="comment"> * return value of &lt;tt&gt;null&lt;/tt&gt; does not &lt;i&gt;necessarily&lt;/i&gt; indicate</span></span><br><span class="line"><span class="comment"> * that the map contained no mapping for the key; it's also possible</span></span><br><span class="line"><span class="comment"> * that the map explicitly mapped the key to &lt;tt&gt;null&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The map will not contain a mapping for the specified key once the</span></span><br><span class="line"><span class="comment"> * call returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="comment">// 找到数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>计算 hash 并找到数组中的位置；</li>
<li>遍历链表，找到则删除；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>WeakHashMap 使用 <code>数组 + 链表</code> 的存储结构；</li>
<li>WeakHashMap 中的 key 是弱引用，GC 的时候会被清除；</li>
<li>WeakHashMap 增加元素，会检查元素是否失效，失效的元素会被删除；</li>
<li>String 作为 key 时，一定要 <code>new String()</code> 这样的方式声明才会失效；</li>
</ul>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a><table><tr><font color="#009100">小知识</font></tr></table></h1><ul>
<li><p>强引用</p>
<blockquote>
<p>如果一个对象具有强引用，它绝对不会被gc回收。如果内存空间不足了，gc宁愿抛出OutOfMemoryError，也不是会回收具有强引用的对象。</p>
</blockquote>
</li>
<li><p>软引用</p>
<blockquote>
<p>如果一个对象只具有软引用，则内存空间足够时不会回收它，但内存空间不够时就会回收这部分对象。只要这个具有软引用对象没有被回收，程序就可以正常使用。</p>
</blockquote>
</li>
<li><p>弱引用</p>
<blockquote>
<p>如果一个对象只具有弱引用，则不管内存空间够不够，当gc扫描到它时就会回收它。</p>
</blockquote>
</li>
<li><p>虚引用</p>
<blockquote>
<p>如果一个对象只具有虚引用，那么它就和没有任何引用一样，任何时候都可能被gc回收。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>软（弱、虚）引用必须和一个引用队列（ReferenceQueue）一起使用，当gc回收这个软（弱、虚）引用的对象时，会把这个软（弱、虚）引用放到这个引用队列中。<br>比如，上述的Entry是一个弱引用，它引用的对象是key，当key被回收时，Entry会被放到queue中。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>WeakHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>初识flink</title>
    <url>/2020/02/10/flink-arch/</url>
    <content><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a><table><tr><td bgcolor="#00ffff">导读</td></tr></table></h1><ol>
<li>flink 是怎样诞生的，有什么样的历史？</li>
<li>在大数据数据架构中，flink 扮演什么角色？</li>
<li>flink 是什么，有什么样的基础架构？</li>
<li>怎么理解 flink 的状态？</li>
</ol>
<h1 id="flink的历史"><a href="#flink的历史" class="headerlink" title="flink的历史"></a><table><tr><td bgcolor="#00ffff">flink的历史</td></tr></table></h1><ul>
<li><p><strong>2010</strong><br>  柏林工业大学、柏林洪堡大学、哈索普拉特纳研究所 联合发起的研究项目 [Stratosphere: Information Management on the Cloud]</p>
</li>
<li><p><strong>2014</strong><br>  Stratosphere 更名为 Flink，并成为 Apache Software Fundation 顶级项目。<br>  Stratosphere 的核心成员创立 Data Artisans 公司，主要业务是将 Stratosphere 实现商业化，为企业提供大数据的解决方案。</p>
</li>
<li><p><strong>2015</strong><br>  Alibaba 对 Flink 进行改造，Blink 诞生。</p>
</li>
<li><p><strong>2019</strong><br>  Alibaba Blink 开源。<br>  Alibaba 收购 Data Artisans。</p>
</li>
</ul>
<h1 id="数据架构的演变"><a href="#数据架构的演变" class="headerlink" title="数据架构的演变"></a><table><tr><td bgcolor="#00ffff">数据架构的演变</td></tr></table></h1><p>从数据架构的演变了解 flink 产生的背景。</p>
<h2 id="传统数据基础架构"><a href="#传统数据基础架构" class="headerlink" title="传统数据基础架构"></a>传统数据基础架构</h2><p><strong>传统单体数据架构（Monolithic Architecture）</strong>： 集中式数据存储。</p>
<img src="/2020/02/10/flink-arch/monolithic_arch.png" class>

<blockquote>
<p>单体应用前期效率高，随着业务的增加，系统越来越难以维护和升级。<br>引入微服务架构，解决业务扩展的问题。</p>
</blockquote>
<p><strong>微服务架构（Microservices Architecture）</strong>：一个应用由多个小的、相互独立的微服务组成。数据分开存储，开发和部署没有依赖。</p>
<img src="/2020/02/10/flink-arch/microservice_arch.png" class>

<blockquote>
<p>业务交易数据过于分散，难以集中化管理（数据分析或者数据挖掘之类的需求）。<br>将数据同步到数据仓库中，在数据仓库中进行数据的抽取、转换、加载（ETL），从而构建成不同的数据集市和应用。</p>
</blockquote>
<h2 id="大数据数据架构"><a href="#大数据数据架构" class="headerlink" title="大数据数据架构"></a>大数据数据架构</h2><p>Lambda架构是由Storm的作者Nathan Marz提出的一个实时大数据处理框架。Marz在Twitter工作期间开发了著名的实时大数据处理框架Storm，Lambda架构是其根据多年进行分布式大数据系统的经验总结提炼而成。</p>
<img src="/2020/02/10/flink-arch/lambda_arch.png" class>

<p><strong>Lambda架构关键特性</strong></p>
<ul>
<li><p>Robust and fault-tolerant（容错性和鲁棒性）</p>
<blockquote>
<p>人和机器的错误都有可能导致系统宕机，让系统能够从错误中快速恢复尤其重要。</p>
</blockquote>
</li>
<li><p>Low latency reads and updates（低延时）</p>
<blockquote>
<p>很多应用对于读和写操作的延时要求非常高，要求对更新和查询的响应是低延时的。</p>
</blockquote>
</li>
<li><p>Scalable（横向扩容）</p>
<blockquote>
<p>当数据量/负载增大时，可扩展性的系统通过增加更多的机器资源来维持性能。也就是常说的系统需要线性可扩展，通常采用scale out（通过增加机器的个数）而不是scale up（通过增强机器的性能）。</p>
</blockquote>
</li>
<li><p>General（通用性）</p>
<blockquote>
<p>系统需要能够适应广泛的应用，包括金融领域、社交网络、电子商务数据分析等。</p>
</blockquote>
</li>
<li><p>Extensible（可扩展）</p>
<blockquote>
<p>需要增加新功能、新特性时，可扩展的系统能以最小的开发代价来增加新功能。</p>
</blockquote>
</li>
<li><p>Allows ad hoc queries（方便查询）</p>
<blockquote>
<p>数据中蕴含有价值，需要能够方便、快速的查询出所需要的数据。</p>
</blockquote>
</li>
<li><p>Minimal maintenance（易于维护）</p>
<blockquote>
<p>系统要想做到易于维护，其关键是控制其复杂性，越是复杂的系统越容易出错、越难维护。</p>
</blockquote>
</li>
<li><p>Debuggable（易调试）</p>
<blockquote>
<p>当出问题时，系统需要有足够的信息来调试错误，找到问题的根源。其关键是能够追根溯源到每个数据生成点。</p>
</blockquote>
</li>
</ul>
<p><a href="https://jiang-hao.com/articles/2019/big-data-lambda-architecture.html" target="_blank" rel="noopener">Lambda架构推荐文档</a><br><a href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html" target="_blank" rel="noopener">AWS Lambda 服务文档</a></p>
<h2 id="有状态流计算架构"><a href="#有状态流计算架构" class="headerlink" title="有状态流计算架构"></a>有状态流计算架构</h2><p>在数据产生的过程中，进行计算，并直接产生结果。必须满足高性能、高吞吐、低延时等多目标。</p>
<img src="/2020/02/10/flink-arch/state_arch.png" class>

<p>Lambda 架构使数据与计算分离，而在实时计算层，对技术有了更高的要求。flink 正是满足了高吞吐、低延迟、高性能、高容错等特性，应运而生。</p>
<h2 id="流数据处理产品对比"><a href="#流数据处理产品对比" class="headerlink" title="流数据处理产品对比"></a>流数据处理产品对比</h2><table>
<thead>
<tr>
<th align="center">产品</th>
<th align="center">模型</th>
<th align="center">API</th>
<th align="center">保证次数</th>
<th align="center">容错机制</th>
<th align="center">状态管理</th>
<th align="center">延时</th>
<th align="center">吞吐量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Storm</td>
<td align="center">Native<br>(数据进入立即处理)</td>
<td align="center">组合式<br>(基础API)</td>
<td align="center">At-least-once</td>
<td align="center">Record Acks(Ack机制)</td>
<td align="center">无</td>
<td align="center">Low</td>
<td align="center">Low</td>
</tr>
<tr>
<td align="center">Spark Stream</td>
<td align="center">mirco-batching<br>(微批量处理)</td>
<td align="center">声明式<br>(封装后的高阶函数)</td>
<td align="center">Exectly-once</td>
<td align="center">RDD Checkpoint(基于RDD checkpoint)</td>
<td align="center">基于DStream</td>
<td align="center">Medium</td>
<td align="center">High</td>
</tr>
<tr>
<td align="center">Flink</td>
<td align="center">Native<br>(数据进入立即处理)</td>
<td align="center">声明式<br>(封装后的高阶函数)</td>
<td align="center">Exectly-once</td>
<td align="center">Checkpoint(flink的快照)</td>
<td align="center">基于操作</td>
<td align="center">Low</td>
<td align="center">High</td>
</tr>
</tbody></table>
<h1 id="flink-是什么？"><a href="#flink-是什么？" class="headerlink" title="flink 是什么？"></a><table><tr><td bgcolor="#00ffff">flink 是什么？</td></tr></table></h1><p><strong>flink</strong>：数据流上有状态的计算</p>
<p><img src="https://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/images/WI7lRD.jpg" alt></p>
<p><strong>flink优势</strong></p>
<ul>
<li><p>同时支持高吞吐、低延迟、高性能</p>
<blockquote>
<p>相对于 Spark Stream、Storm</p>
</blockquote>
</li>
<li><p>支持事件时间概念（Event Time）</p>
<blockquote>
<p>针对窗口计算</p>
</blockquote>
</li>
<li><p>支持有状态计算（State）</p>
<blockquote>
<p>状态：算子计算的中间结果。<br>新的事件进入算子，可以从之前的状态中获取中间结果来计算当前的结果。</p>
</blockquote>
</li>
<li><p>支持高度灵活的窗口计算（Window）</p>
<blockquote>
<p>对流数据进行一定范围的计算。</p>
</blockquote>
</li>
<li><p>基于轻量级分布式快照实现的容错（Snapshot）</p>
<blockquote>
<p>CheckPoint</p>
</blockquote>
</li>
<li><p>基于JVM实现独立的内存管理</p>
<blockquote>
<p>flink实现了自身内存管理机制，尽可能地减少JVM GC对系统的影响。</p>
</blockquote>
</li>
<li><p>保存点（Save Points）</p>
<blockquote>
<p>任务执行快照保存在存储介质，任务重启时从Save Points恢复原有的计算状态。</p>
</blockquote>
</li>
</ul>
<h1 id="flink-应用场景"><a href="#flink-应用场景" class="headerlink" title="flink 应用场景"></a><table><tr><td bgcolor="#00ffff">flink 应用场景</td></tr></table></h1><h2 id="事件驱动（Event-driven）"><a href="#事件驱动（Event-driven）" class="headerlink" title="事件驱动（Event-driven）"></a>事件驱动（Event-driven）</h2><p><img src="https://flink.apache.org/img/usecases-eventdrivenapps.png" alt></p>
<p>复杂事件处理</p>
<h2 id="数据分析（Data-Analytics）"><a href="#数据分析（Data-Analytics）" class="headerlink" title="数据分析（Data Analytics）"></a>数据分析（Data Analytics）</h2><p><img src="https://flink.apache.org/img/usecases-analytics.png" alt></p>
<p>实时大屏、实时报表、实时欺诈检测</p>
<h2 id="数据管道（Data-Pipeline）"><a href="#数据管道（Data-Pipeline）" class="headerlink" title="数据管道（Data Pipeline）"></a>数据管道（Data Pipeline）</h2><p><img src="https://flink.apache.org/img/usecases-datapipelines.png" alt></p>
<p>实时智能推荐系统、实时数仓</p>
<p><a href="https://flink.apache.org/zh/usecases.html" target="_blank" rel="noopener">官方中文文档</a><br><a href="https://flink.apache.org/usecases.html" target="_blank" rel="noopener">官方英文文档</a></p>
<h1 id="flink-基础架构"><a href="#flink-基础架构" class="headerlink" title="flink 基础架构"></a><table><tr><td bgcolor="#00ffff">flink 基础架构</td></tr></table></h1><p><img src="https://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/images/sMDTgD.jpg" alt></p>
<p>flink 的核心组件和运行时组件</p>
<h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.9/fig/stack.png" alt></p>
<p>从上往下：</p>
<ul>
<li><p>API &amp; Libraries 层</p>
<blockquote>
<p>提供批处理和流处理接口，同时在此基础上抽象出不同的应用类型的组件库。</p>
</blockquote>
</li>
<li><p>Runtime 核心层</p>
<blockquote>
<p>主要负责对上层不同接口提供基础服务。<br>支持分布式 Stream 作业的执行、JobGraph 到 ExecutionGraph 的映射转换、任务调度等。<br>将 DataStream 和 DataSet 转成统一的可执行的 Task Operator，达到在流式引擎下同时处理批量计算和流式计算的目的。</p>
</blockquote>
</li>
<li><p>物理部署层</p>
<blockquote>
<p>flink 部署模式，目前支持本地、集群（Standalone/YARN）、云（GCE/EC2）、Kubenetes。</p>
</blockquote>
</li>
</ul>
<h2 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h2><p>运行时两种类型的程序：JobManagers（Masters）、TaskManagers（Workers）</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.9/fig/processes.svg" alt></p>
<ul>
<li><p>JobManagers</p>
<blockquote>
<p>  负责整个 Flink 集群任务调度及资源的管理。JobManagers 和 TaskManagers 之间通过 Actor System 进行通信。组件之间的通信是基于 Akka Framework 实现。 </p>
</blockquote>
</li>
<li><p>TaskManagers</p>
<blockquote>
<p>  负责具体的任务执行和对应的任务在每个节点上的资源申请与管理。<br>  flink 的任务运行采用的是多线程的方式，在多个任务和 Task 之间通过 TaskSlot 方式共享系统资源，每个 TaskManager 中管理多个 TaskSlot 资源池。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="Tasks、Operator-Chains"><a href="#Tasks、Operator-Chains" class="headerlink" title="Tasks、Operator Chains"></a>Tasks、Operator Chains</h3><p>在分布式执行程序中，Operator Chains 将 subtasks 连接在 Tasks 中。每一个 Task 由一个线程执行。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/tasks_chains.svg" alt></p>
<hr>
<h3 id="Task-Slots、Resources"><a href="#Task-Slots、Resources" class="headerlink" title="Task Slots、Resources"></a>Task Slots、Resources</h3><p>Task Slots、Subtasks、TaskManage之间的关系</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/tasks_slots.svg" alt></p>
<blockquote>
<p>Taskmanage 是一个独立的 JVM 程序，Subtasks 在独立的线程中执行，Task Slots（任务槽）控制着多少个任务可以被执行。Slots 保留并管理内存空间，但是并没有独立的 CPU 。</p>
</blockquote>
<p><strong>Task Slots 任务槽资源共享</strong></p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/slot_sharing.svg" alt></p>
<p>Task Slots 资源共享有两个好处：</p>
<blockquote>
<ul>
<li>不需要计算一个程序总共包含多少个任务。</li>
<li>可以更好地利用资源。（非密集型子任务和资源密集型窗口子任务）</li>
</ul>
</blockquote>
<hr>
<h3 id="State-Backends"><a href="#State-Backends" class="headerlink" title="State Backends"></a>State Backends</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.10/fig/checkpoints.svg" alt></p>
<blockquote>
<p>State Backends 决定了state如何被存储、访问和维持。它的主要职责是本地 state 管理和checkpoint state到远程。在管理方面，可选择将 state 存储到内存还是磁盘。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><td bgcolor="#00ffff">总结</td></tr></table></h1><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><td bgcolor="#00ffff">参考文档</td></tr></table></h1><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/concepts/runtime.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.10/concepts/runtime.html</a><br>《Flink原理、实践与性能优化》— 机械工业出版社、张利兵著<br><a href="https://www.cnblogs.com/code2one/p/10123112.html" target="_blank" rel="noopener">https://www.cnblogs.com/code2one/p/10123112.html</a><br><a href="http://www.54tianzhisheng.cn/2018/10/13/flink-introduction/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/10/13/flink-introduction/</a><br><a href="https://jiang-hao.com/articles/2019/big-data-lambda-architecture.html" target="_blank" rel="noopener">https://jiang-hao.com/articles/2019/big-data-lambda-architecture.html</a><br><a href="https://blog.csdn.net/github_39577257/article/details/94230550" target="_blank" rel="noopener">https://blog.csdn.net/github_39577257/article/details/94230550</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>hbase java编程</title>
    <url>/2020/02/10/hbase-java/</url>
    <content><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a><table><tr><td bgcolor="#00ffff">导读</td></tr></table></h1><ol>
<li>docker run hbase</li>
<li>Hbase Java tutorial</li>
</ol>
<h1 id="docker-run-hbase"><a href="#docker-run-hbase" class="headerlink" title="docker run hbase"></a><table><tr><td bgcolor="#00ffff">docker run hbase</td></tr></table></h1><p>1.查找镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search hbase</span><br></pre></td></tr></table></figure>

<p>hbase 运行依赖于 zookeeper，而 harisekhon/hbase:1.3 是一个自带 zookeeper 的镜像，使用这个镜像启动一个单节点hbase服务，快速、方便、简单。</p>
<p>2.运行镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -h myhbase -p 2181:2181 \</span><br><span class="line">    -p 8080:8080 -p 8085:8085 -p 9090:9090 \</span><br><span class="line">    -p 9095:9095 -p 16000:16000 -p 16010:16010 \</span><br><span class="line">    -p 16201:16201 -p 16301:16301 \</span><br><span class="line">    --name hbase1.3 harisekhon/hbase:1.3</span><br></pre></td></tr></table></figure>

<p>3.修改 hosts 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">127.0.0.1       myhbase</span><br></pre></td></tr></table></figure>

<p>4.shell操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接本地</span></span><br><span class="line">./bin/hbase shell</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程连接</span></span><br><span class="line">./bin/hbase shell -Dhbase.zookeeper.quorum=cnsz22pl0122,cnsz22pl0123,cnsz22pl0124</span><br></pre></td></tr></table></figure>

<p><a href="https://hbase.apache.org/book.html#quickstart" target="_blank" rel="noopener">https://hbase.apache.org/book.html#quickstart</a></p>
<h1 id="Hbase-Java-tutorial"><a href="#Hbase-Java-tutorial" class="headerlink" title="Hbase Java tutorial"></a><table><tr><td bgcolor="#00ffff">Hbase Java tutorial</td></tr></table></h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><td bgcolor="#00ffff">总结</td></tr></table></h1><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><td bgcolor="#00ffff">参考文档</td></tr></table></h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hbase</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java FAQ</title>
    <url>/2020/02/10/faq/java/</url>
    <content><![CDATA[<h1 id="非线程安全集合"><a href="#非线程安全集合" class="headerlink" title="非线程安全集合"></a><table><tr><font color="#009100">非线程安全集合</font></tr></table></h1><h2 id="java-util-包下的非线程安全集合"><a href="#java-util-包下的非线程安全集合" class="headerlink" title="java.util 包下的非线程安全集合"></a>java.util 包下的非线程安全集合</h2><h2 id="1-ArrayList与LinkedList的实现和区别？"><a href="#1-ArrayList与LinkedList的实现和区别？" class="headerlink" title="1. ArrayList与LinkedList的实现和区别？"></a>1. ArrayList与LinkedList的实现和区别？</h2><blockquote>
<ul>
<li>结构上的区别：<br>　　　ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>性能上的区别：</li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>查询</strong><br>  ArrayList是随机访问(random access)策略，而LinkedList是不支持快速的随机访问的（访问链表中的某个元素时，就必须从链表的一端开始沿着连接方向一个一个元素地去查找，直到找到所需的元素为止）。对一个LinkedList做随机访问所消耗的时间与这个表的大小是成比例的。而相应的，在ArrayList中进行随机访问所消耗的时间是固定的。 </p>
</blockquote>
<blockquote>
<p>  <strong>增删</strong><br>  1). 若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。<br>  2). 若是批量插入或删除数据：<br>　　ArrayList 是基于数组实现的，而数组是一块连续的内存空间，当在表的前面或中间插入或删除元素时，所有已经存在的元素都会后移，这就意味着数据移动和复制上的开销，当在表的后面插入或删除元素时，ArrayList和LinkedList数据量小时速度相差无几，但数据量较大时ArrayList的速度快。在末尾插入或删除数据，arraylist的速度比linkedlist的速度反而要快。注：其实在前方插入时，ArrayList可以使用后方插入，最后再使用Collections.reverse()方法反转，速度比LinkedList快。<br>　　　LinkedList 插入或删除数据则只是简单的未这个元素分配一个记录，然后调整两个连接，在表的尾端插入数据与在任意位置插入数据是一样的，不会因为插入的位置靠前而导致插入的方法性能降低。<br>　　　遍历列表：最简便的ForEach循环并没有很好的性能表现，综合性能不如普通的迭代器，而是用for循环通过随机访问遍历列表时，ArrayList表项很好，但是LinkedList的表现却无法让人接受，甚至没有办法等待程序的结束。这是因为对LinkedList进行随机访问时，总会进行一次列表的遍历操作。性能非常差，应避免使用。</p>
</blockquote>
<blockquote>
<p><strong>总结：</strong><br>　　1、在ArrayList的 中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>　　2、ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。<br>　　3、LinkedList不支持高效的随机元素访问。<br>　　4、ArrayList的查询效率比较高，增删动作的效率比较差，适用于查询比较频繁，增删动作较少的元素管理的集合。<br>　　　LinkedList的查询效率低，但是增删效率很高。适用于增删动作的比较频繁，查询次数较少的元素管理集合。</p>
</blockquote>
<h2 id="2-HashMap-数据结构-hash冲突如何解决（链表和红黑树-扩容时机-扩容时避免rehash的优化"><a href="#2-HashMap-数据结构-hash冲突如何解决（链表和红黑树-扩容时机-扩容时避免rehash的优化" class="headerlink" title="2. HashMap 数据结构? hash冲突如何解决（链表和红黑树)? 扩容时机? 扩容时避免rehash的优化?"></a>2. HashMap 数据结构? hash冲突如何解决（链表和红黑树)? 扩容时机? 扩容时避免rehash的优化?</h2><blockquote>
<ul>
<li>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构</li>
<li>hash冲突时，使用链表和红黑树来解决</li>
<li>设置好初始化容量，初始容量（expectedSize / 0.75F + 1.0F）</li>
</ul>
</blockquote>
<h2 id="3-LinkedHashMap-基本原理？-哪两种有序？-如何用来实现-LRU-缓存策略？"><a href="#3-LinkedHashMap-基本原理？-哪两种有序？-如何用来实现-LRU-缓存策略？" class="headerlink" title="3. LinkedHashMap 基本原理？ 哪两种有序？ 如何用来实现 LRU 缓存策略？"></a>3. LinkedHashMap 基本原理？ 哪两种有序？ 如何用来实现 LRU 缓存策略？</h2><blockquote>
<ul>
<li>LinkedHashMap可以看成是 LinkedList + HashMap</li>
<li>LinkedHashMap继承HashMap，拥有HashMap的所有特性，并且额外增加了按一定顺序访问的特性</li>
<li>如果accessOrder为false，则可以按插入元素的顺序遍历元素</li>
<li>如果accessOrder为true，则可以按访问元素的顺序遍历元素</li>
<li>如果accessOrder为true，就可以实现了 LRU 缓存策略</li>
</ul>
</blockquote>
<h2 id="4-TreeMap-数据结构？key对象为什么必须要实现Compare接口？-如何用它实现一致性哈希？"><a href="#4-TreeMap-数据结构？key对象为什么必须要实现Compare接口？-如何用它实现一致性哈希？" class="headerlink" title="4. TreeMap 数据结构？key对象为什么必须要实现Compare接口？ 如何用它实现一致性哈希？"></a>4. TreeMap 数据结构？key对象为什么必须要实现Compare接口？ 如何用它实现一致性哈希？</h2><blockquote>
<ul>
<li>TreeMap的存储结构是一棵红黑树</li>
<li>TreeMap中的元素是有序的，按key的顺序排列</li>
<li>tailMap 方法可以找到大于等于目标 key 的元素，利用这一特性，可以实现一致性哈希</li>
</ul>
</blockquote>
<h1 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a><table><tr><font color="#009100">线程安全集合</font></tr></table></h1><h2 id="java-util-concurrent-包下的线程安全集合"><a href="#java-util-concurrent-包下的线程安全集合" class="headerlink" title="java.util.concurrent 包下的线程安全集合"></a>java.util.concurrent 包下的线程安全集合</h2><hr>
<p>title: Java FAQ<br>date: 2020-02-10 17:52:19<br>comments: true #是否可评论<br>toc: true #是否显示文章目录<br>categories: Java<br>tags: [Java, faq]</p>
<hr>
<h1 id="非线程安全集合-1"><a href="#非线程安全集合-1" class="headerlink" title="非线程安全集合"></a><table><tr><font color="#009100">非线程安全集合</font></tr></table></h1><h2 id="java-util-包下的非线程安全集合-1"><a href="#java-util-包下的非线程安全集合-1" class="headerlink" title="java.util 包下的非线程安全集合"></a>java.util 包下的非线程安全集合</h2><h2 id="1-ArrayList与LinkedList的实现和区别？-1"><a href="#1-ArrayList与LinkedList的实现和区别？-1" class="headerlink" title="1. ArrayList与LinkedList的实现和区别？"></a>1. ArrayList与LinkedList的实现和区别？</h2><blockquote>
<ul>
<li>结构上的区别：<br>　　　ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>性能上的区别：</li>
</ul>
</blockquote>
<blockquote>
<p>  <strong>查询</strong><br>  ArrayList是随机访问(random access)策略，而LinkedList是不支持快速的随机访问的（访问链表中的某个元素时，就必须从链表的一端开始沿着连接方向一个一个元素地去查找，直到找到所需的元素为止）。对一个LinkedList做随机访问所消耗的时间与这个表的大小是成比例的。而相应的，在ArrayList中进行随机访问所消耗的时间是固定的。 </p>
</blockquote>
<blockquote>
<p>  <strong>增删</strong><br>  1). 若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。<br>  2). 若是批量插入或删除数据：<br>　　ArrayList 是基于数组实现的，而数组是一块连续的内存空间，当在表的前面或中间插入或删除元素时，所有已经存在的元素都会后移，这就意味着数据移动和复制上的开销，当在表的后面插入或删除元素时，ArrayList和LinkedList数据量小时速度相差无几，但数据量较大时ArrayList的速度快。在末尾插入或删除数据，arraylist的速度比linkedlist的速度反而要快。注：其实在前方插入时，ArrayList可以使用后方插入，最后再使用Collections.reverse()方法反转，速度比LinkedList快。<br>　　　LinkedList 插入或删除数据则只是简单的未这个元素分配一个记录，然后调整两个连接，在表的尾端插入数据与在任意位置插入数据是一样的，不会因为插入的位置靠前而导致插入的方法性能降低。<br>　　　遍历列表：最简便的ForEach循环并没有很好的性能表现，综合性能不如普通的迭代器，而是用for循环通过随机访问遍历列表时，ArrayList表项很好，但是LinkedList的表现却无法让人接受，甚至没有办法等待程序的结束。这是因为对LinkedList进行随机访问时，总会进行一次列表的遍历操作。性能非常差，应避免使用。</p>
</blockquote>
<blockquote>
<p><strong>总结：</strong><br>　　1、在ArrayList的 中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>　　2、ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。<br>　　3、LinkedList不支持高效的随机元素访问。<br>　　4、ArrayList的查询效率比较高，增删动作的效率比较差，适用于查询比较频繁，增删动作较少的元素管理的集合。<br>　　　LinkedList的查询效率低，但是增删效率很高。适用于增删动作的比较频繁，查询次数较少的元素管理集合。</p>
</blockquote>
<h2 id="2-HashMap-数据结构-hash冲突如何解决（链表和红黑树-扩容时机-扩容时避免rehash的优化-1"><a href="#2-HashMap-数据结构-hash冲突如何解决（链表和红黑树-扩容时机-扩容时避免rehash的优化-1" class="headerlink" title="2. HashMap 数据结构? hash冲突如何解决（链表和红黑树)? 扩容时机? 扩容时避免rehash的优化?"></a>2. HashMap 数据结构? hash冲突如何解决（链表和红黑树)? 扩容时机? 扩容时避免rehash的优化?</h2><blockquote>
<ul>
<li>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构</li>
<li>hash冲突时，使用链表和红黑树来解决</li>
<li>设置好初始化容量，初始容量（expectedSize / 0.75F + 1.0F）</li>
</ul>
</blockquote>
<h2 id="3-LinkedHashMap-基本原理？-哪两种有序？-如何用来实现-LRU-缓存策略？-1"><a href="#3-LinkedHashMap-基本原理？-哪两种有序？-如何用来实现-LRU-缓存策略？-1" class="headerlink" title="3. LinkedHashMap 基本原理？ 哪两种有序？ 如何用来实现 LRU 缓存策略？"></a>3. LinkedHashMap 基本原理？ 哪两种有序？ 如何用来实现 LRU 缓存策略？</h2><blockquote>
<ul>
<li>LinkedHashMap可以看成是 LinkedList + HashMap</li>
<li>LinkedHashMap继承HashMap，拥有HashMap的所有特性，并且额外增加了按一定顺序访问的特性</li>
<li>如果accessOrder为false，则可以按插入元素的顺序遍历元素</li>
<li>如果accessOrder为true，则可以按访问元素的顺序遍历元素</li>
<li>如果accessOrder为true，就可以实现了 LRU 缓存策略</li>
</ul>
</blockquote>
<h2 id="4-TreeMap-数据结构？key对象为什么必须要实现Compare接口？-如何用它实现一致性哈希？-1"><a href="#4-TreeMap-数据结构？key对象为什么必须要实现Compare接口？-如何用它实现一致性哈希？-1" class="headerlink" title="4. TreeMap 数据结构？key对象为什么必须要实现Compare接口？ 如何用它实现一致性哈希？"></a>4. TreeMap 数据结构？key对象为什么必须要实现Compare接口？ 如何用它实现一致性哈希？</h2><blockquote>
<ul>
<li>TreeMap的存储结构是一棵红黑树</li>
<li>TreeMap中的元素是有序的，按key的顺序排列</li>
<li>tailMap 方法可以找到大于等于目标 key 的元素，利用这一特性，可以实现一致性哈希</li>
</ul>
</blockquote>
<h1 id="线程安全集合-1"><a href="#线程安全集合-1" class="headerlink" title="线程安全集合"></a><table><tr><font color="#009100">线程安全集合</font></tr></table></h1><h2 id="java-util-concurrent-包下的线程安全集合-1"><a href="#java-util-concurrent-包下的线程安全集合-1" class="headerlink" title="java.util.concurrent 包下的线程安全集合"></a>java.util.concurrent 包下的线程安全集合</h2>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>faq</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Bubble Sort</title>
    <url>/2020/02/10/algorithm/bubble-sort/</url>
    <content><![CDATA[<h1 id="冒泡排序实现思路"><a href="#冒泡排序实现思路" class="headerlink" title="冒泡排序实现思路"></a><table><tr><font color="#009100">冒泡排序实现思路</font></tr></table></h1><ol>
<li>将序列中所有元素两两比较，将最大的放在最后面。</li>
<li>将剩余序列中所有元素两两比较，将最大的放在最后面。</li>
<li>重复第二步，直到只剩下一个数。</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><table><tr><font color="#009100">代码实现</font></tr></table></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;length - i -<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                tmp = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="keyword">false</span>;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - j; i++) &#123;                                       </span><br><span class="line">              <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;                          </span><br><span class="line">                    tmp = arr[i];</span><br><span class="line">                    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                    arr[i + <span class="number">1</span>] = tmp;</span><br><span class="line">                    swapped = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;                </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif" alt="动画效果"></p>
<p><a href="http://www.jsons.cn/sort/" target="_blank" rel="noopener">动画演示</a></p>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><table><tr><font color="#009100">复杂度分析</font></tr></table></h1><p>最好的情况下（完全正序）复杂度是 O(1)；最糟糕的情况下（完全倒序），复杂度是 O(n^2)</p>
<h1 id="参阅文档"><a href="#参阅文档" class="headerlink" title="参阅文档"></a><table><tr><font color="#009100">参阅文档</font></tr></table></h1><p><a href="http://www.algolist.net/Algorithms/Sorting/Bubble_sort" target="_blank" rel="noopener">http://www.algolist.net/Algorithms/Sorting/Bubble_sort</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>bubble</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayDeque 源码</title>
    <url>/2020/02/10/list/arraydeque/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ol>
<li>ArrayDeque 如何实现双端队列的？</li>
<li>ArrayDeque 操作队列的头部和尾部指针有什么特别技巧，如何防止移位越界？</li>
<li>ArrayDeque 有界吗？</li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><ul>
<li>双端队列，非线程安全<blockquote>
<p>ArrayDeque 是一种以数组方式实现的双端队列（两端可以进出），非线程安全。</p>
</blockquote>
</li>
</ul>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/arraydeque/arraydeque.png" alt="ArrayDeque 继承结构"></p>
<ul>
<li>ArrayDeque 继承 <code>AbstractCollection&lt;E&gt;</code></li>
</ul>
<blockquote>
<p>可求两个集合的并集、差集、交集等方法</p>
</blockquote>
<ul>
<li>ArrayDeque 实现了 <code>Deque&lt;E&gt;</code> 接口</li>
</ul>
<blockquote>
<p>实现双队列方法，具有双端队列属性</p>
</blockquote>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array in which the elements of the deque are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the deque is the length of this array, which is</span></span><br><span class="line"><span class="comment"> * always a power of two. The array is never allowed to become</span></span><br><span class="line"><span class="comment"> * full, except transiently within an addX method where it is</span></span><br><span class="line"><span class="comment"> * resized (see doubleCapacity) immediately upon becoming full,</span></span><br><span class="line"><span class="comment"> * thus avoiding head and tail wrapping around to equal each</span></span><br><span class="line"><span class="comment"> * other.  We also guarantee that all array cells not holding</span></span><br><span class="line"><span class="comment"> * deque elements are always null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The index of the element at the head of the deque (which is the</span></span><br><span class="line"><span class="comment"> * element that would be removed by remove() or pop()); or an</span></span><br><span class="line"><span class="comment"> * arbitrary number equal to tail if the deque is empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The index at which the next element would be added to the tail</span></span><br><span class="line"><span class="comment"> * of the deque (via addLast(E), add(E), or push(E)).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The minimum capacity that we'll use for a newly created deque.</span></span><br><span class="line"><span class="comment"> * Must be a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ArrayDeque 底层使用数组存储，容量大小总是 2^n</p>
</li>
<li><p>ArrayDeque 使用头部和尾部指针标识</p>
</li>
<li><p>ArrayDeque 的最小总量是 8</p>
</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty array deque with an initial capacity</span></span><br><span class="line"><span class="comment"> * sufficient to hold 16 elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty array deque with an initial capacity</span></span><br><span class="line"><span class="comment"> * sufficient to hold the specified number of elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numElements  lower bound on initial capacity of the deque</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a deque containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.  (The first element returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator becomes the first element, or &lt;i&gt;front&lt;/i&gt; of the</span></span><br><span class="line"><span class="comment"> * deque.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into the deque</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates empty array to hold the given number of elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numElements  the number of elements to hold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">    <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不指定初始化容量，默认是 16</li>
<li>指定初始化容量，计算最合适的容量（2^n）</li>
<li>最大分配容量的 2^30 </li>
</ul>
<p><strong>知识点</strong></p>
<blockquote>
<p>如何找到大于一个正整数N的最小2的次幂数，参考 <code>calculateSize(int numElements)</code> 方法。<br><a href="https://www.freesion.com/article/900736401/" target="_blank" rel="noopener">详细解读</a></p>
</blockquote>
<h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>入队有很多方法，主要是调用以下两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the front of this deque.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the end of this deque.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两种入队方式，从队列头或者从队列尾</li>
<li>如果容量不够，直接扩大为两倍</li>
<li>头部指针和尾部指针在数组范围内循环</li>
</ul>
<p><strong>知识点</strong></p>
<blockquote>
<p>一个容量为 2^n 的数组，增减元素时移动前后指针，如何使用最优的方式解决指针越界的问题？</p>
<ul>
<li>前提：<code>elements.length</code> 是 2^n</li>
<li><code>head = (head - 1) &amp; (elements.length - 1)</code> 头部指针前移一位 </li>
<li><code>tail = (tail + 1) &amp; (elements.length - 1)</code> 尾部指针后移一位</li>
</ul>
</blockquote>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>ArrayDeque 扩容为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Doubles the capacity of this deque.  Call only when full, i.e.,</span></span><br><span class="line"><span class="comment"> * when head and tail have wrapped around to become equal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> n = elements.length;</span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建新的数组为原来的两倍</li>
<li>从旧的数组拷贝到新数组</li>
<li>重新设置头部和尾部的指针</li>
</ul>
<h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><p>出队有多种方法，主要调用以下两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[t] = <span class="keyword">null</span>;</span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两种出队方式，从队列头部或者队列尾</li>
<li>与出队一样方式，反向调整指针的位置</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>ArrayDeque 可以作为栈来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this deque.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this deque.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of the queue represented by this deque</span></span><br><span class="line"><span class="comment"> * (in other words, the first element of this deque), or returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; if this deque is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #pollFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of the queue represented by this deque, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if this deque is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pollFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈的特性是先进后出，故只需要操作队列头就可以实现了</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>ArrayDeque 通过数组实现的双端队列；</li>
<li>ArrayDeque 出队入队列是通过操作头部和尾部的指针实现；</li>
<li>ArrayDeque 容量不足是，进行扩容，新容量为原来的 2 倍；</li>
<li>ArrayDeque 的容量都是 2^n ，这样方便操作头部和尾部的指针；</li>
</ul>
<blockquote>
<p><code>head = (head - 1) &amp; (elements.length - 1)</code> 头部指针前移一位<br><code>tail = (tail + 1) &amp; (elements.length - 1)</code> 尾部指针后移一位</p>
</blockquote>
<ul>
<li>ArrayDeque 可作为栈来使用；</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayDeque</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 源码</title>
    <url>/2020/02/10/list/arraylist/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><ul>
<li>动态数组</li>
</ul>
<blockquote>
<p>ArrayList 是基于数组实现的 List，相对于数组， ArrayList 提供了动态扩容的能力，故称之为 <strong>动态数组</strong> 。</p>
</blockquote>
<ul>
<li>自动扩容</li>
</ul>
<blockquote>
<p>ArrayList 允许任何符合规则的元素插入，甚至包括null。在每次增加元素时，都会进行容量检查，快溢出时就会进行扩容，扩容后的容量是原来的1.5倍。</p>
</blockquote>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/arraylist/arraylist.png" alt="ArrayList 继承结构"></p>
<ul>
<li>ArrayList 实现了 <code>List</code> 接口</li>
</ul>
<blockquote>
<p>提供 查询、删除、遍历等操作</p>
</blockquote>
<ul>
<li>ArrayList 实现了 <code>RandomAccess</code> 接口</li>
</ul>
<blockquote>
<p>提供了随机访问的能力</p>
</blockquote>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>DEFAULT_CAPACIT。</li>
</ul>
<blockquote>
<p>默认容量时，创建的空数组；当添加第一个元素后，默认扩容的容量为 10。</p>
</blockquote>
<ul>
<li>EMPTY_ELEMENTDATA</li>
</ul>
<blockquote>
<p>指定容量为 0 时，创建的空数组。 即 <code>new ArrayList(0);</code>，当添加一个元素时，扩容到 1。</p>
</blockquote>
<ul>
<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</li>
</ul>
<blockquote>
<p>默认容量时，创建的空数组。即 <code>new ArrayList();</code>，当添加一个元素时，扩容到 10。</p>
</blockquote>
<ul>
<li>elementData</li>
</ul>
<blockquote>
<p>真正存放元素的地方。使用 <code>transient</code> 修饰，不序列化该字段。<br><a href="https://baijiahao.baidu.com/s?id=1636557218432721275&wfr=spider&for=pc" target="_blank" rel="noopener">关于 transient</a></p>
</blockquote>
<ul>
<li>size</li>
</ul>
<blockquote>
<p>真正存储元素的个数，不是 elementData 的长度。</p>
</blockquote>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList()"></a>ArrayList()</h3><p>无初始容量，初始化为 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 空数组，会在添加第一个元素的时候扩容为默认的大小，即10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-int-initialCapacity"><a href="#ArrayList-int-initialCapacity" class="headerlink" title="ArrayList(int initialCapacity)"></a>ArrayList(int initialCapacity)</h3><p>传入初始化容量。如果初始化容量大于0，则elementData为对应的大小；如果初始化容量等于0，就使用 <code>EMPTY_ELEMENTDATA</code> 空数组；如果小于0，则抛出异常。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="ArrayList-Collection-lt-extends-E-gt-c"><a href="#ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a>ArrayList(Collection&lt;? extends E&gt; c)</h3><p>传入集合并初始化elementData，这里会使用拷贝把传入集合的元素拷贝到elementData数组中，如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p>添加元素到末尾，平均时间复杂度为O(1)</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>检查是否需要扩容；</li>
<li>如果 elementData 等于 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，则需要的容量为 <code>Math.max(DEFAULT_CAPACITY, size + 1)</code>；否则需要的容量为 <code>size + 1</code>；</li>
<li>新容量扩容为原来的 1.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果扩容后的新容量比需要的容量还小，则以需要的容量为准；如果超过了最大容量，以最大容量为准；</li>
<li>最大容量为 <code>Integer.MAX_VALUE - 8</code>，即 (2^31 - 1 - 8)；其中 <code>8 bytes</code> 存储数组本身大小的描述信息；</li>
<li>创建新容量的数据，把原来数组的数据拷贝进去；</li>
</ol>
<h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p>添加元素到指定位置，时间复杂度为O(n).</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A version of rangeCheck used by add and addAll.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>检查索引是否越界；</li>
<li>检查是否需要扩容，如果需要，则进行扩容操作；</li>
<li>拷贝并把插入索引的位置后的元素后移一位；</li>
<li>载入的位置放置要插入的元素；</li>
<li>元素计数器加 1；</li>
</ol>
<h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h3><p>将一个集合追加到另一个集合的尾部。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment"> * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment"> * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment"> * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment"> * list is nonempty.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>将集合转为数组 a；</li>
<li>检查是否需要扩容，如果需要，则执行扩容操作；</li>
<li>把数组 a 中的元素拷贝到 elementData 的尾部；</li>
</ol>
<h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h3><p>将一个集合插入到另一个集合，插入的起点为数组的 index 位置。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment"> *              specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>将集合转为数组 a；</li>
<li>检查是否需要扩容，如果需要，则执行扩容操作；</li>
<li>从 index 开始，将集合中的元素后移 numNew 位；</li>
<li>把数组 a 中的元素拷贝到 elementData 中，起点为 index；</li>
</ol>
<h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><p>获取指定位置的元素，时间复杂度为O(1)。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if the given index is in range.  If not, throws an appropriate</span></span><br><span class="line"><span class="comment"> * runtime exception.  This method does *not* check if the index is</span></span><br><span class="line"><span class="comment"> * negative: It is always used immediately prior to an array access,</span></span><br><span class="line"><span class="comment"> * which throws an ArrayIndexOutOfBoundsException if index is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>检查索引是否越界，如果越界，则抛出 <code>IndexOutOfBoundsException</code> 异常；</li>
<li>返回索引位置处的元素；</li>
</ol>
<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p>删除指定位置的元素，时间复杂度为O(n)。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>检查索引是否越界；</li>
<li>获取指定位置的元素；</li>
<li>如果删除的不是最后一个元素，则从指定位置的后一位元素开始，尾部元素向前移一位；</li>
<li>将最后一个元素置为null；</li>
<li>返回删除的元素；</li>
</ol>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p>删除指定的元素，时间复杂度为O(n)。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>找到第一个等于指定值的元素；</li>
<li>快速删除；</li>
</ol>
<h3 id="retainAll-Collection-lt-gt-c"><a href="#retainAll-Collection-lt-gt-c" class="headerlink" title="retainAll(Collection&lt;?&gt; c)"></a>retainAll(Collection&lt;?&gt; c)</h3><p>取两个集合的交集。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retains only the elements in this list that are contained in the</span></span><br><span class="line"><span class="comment"> * specified collection.  In other words, removes from this list all</span></span><br><span class="line"><span class="comment"> * of its elements that are not contained in the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be retained in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the class of an element of this list</span></span><br><span class="line"><span class="comment"> *         is incompatible with the specified collection</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if this list contains a null element and the</span></span><br><span class="line"><span class="comment"> *         specified collection does not permit null elements</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment"> *         or if the specified collection is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>遍历elementData数组；</li>
<li>如果元素在c中，则把这个元素添加到elementData数组的 w 位置，并将 w 位置往后移一位；</li>
<li>遍历完之后，w 之前的元素都是两者共有的，w 之后（包含）的元素不是两者共有的；</li>
<li>将 w 之后（包含）的元素置为null；</li>
</ol>
<h3 id="removeAll-Collection-lt-gt-c"><a href="#removeAll-Collection-lt-gt-c" class="headerlink" title="removeAll(Collection&lt;?&gt; c)"></a>removeAll(Collection&lt;?&gt; c)</h3><p>求两个集合的差集，只保留不在集合 C 中的元素。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes from this list all of its elements that are contained in the</span></span><br><span class="line"><span class="comment"> * specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be removed from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the class of an element of this list</span></span><br><span class="line"><span class="comment"> *         is incompatible with the specified collection</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if this list contains a null element and the</span></span><br><span class="line"><span class="comment"> *         specified collection does not permit null elements</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment"> *         or if the specified collection is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>与 <code>retainAll(Collection&lt;?&gt; c)</code> 方法类似，<code>batchRemove(c, false)</code> 只保存不存在的元素。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ol>
<li>ArrayList 底层使用数组存储元素，当数组长度不够时进行扩容，每次扩容为原来的 1.5 倍；对集合元素进行删除操作不会缩容；</li>
<li>ArrayList 支持随机访问，通过索引访问元素，时间复杂度为O(1)；</li>
<li>ArrayList 在尾部添加（或删除）元素，时间复杂度为O(1)；</li>
<li>ArrayList 在中间添加（或删除）元素，要进行元素的移位，时间复杂度为O(n)；</li>
<li>ArrayList 支持求集合并集：addAll(Collection&lt;? extends E&gt; c)；</li>
<li>ArrayList 支持求集合交集：retainAll(Collection&lt;?&gt; c)；</li>
<li>ArrayList 支持求集合的差集：removeAll(Collection&lt;?&gt; c)；</li>
</ol>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title=" FAQ "></a><table><tr><font color="#009100"> FAQ </font></tr></table></h1><p><strong>Q：ArrayList、Vector、LinkedList的区别？</strong></p>
<blockquote>
<ul>
<li>Vector 和 ArrayList 都是以类似数组的形式存储在内存中，LinkedList 以链表的形式进行存储</li>
<li>Vector 线程同步，ArrayList 和 LinkedList 线程不同步</li>
<li>LinkedList 适合在指定位置进行插入、删除等操作，不适合查找，Vector、ArrayList 适合查找</li>
<li>Vector 默认扩充为原来的两倍，ArrayList 默认扩充为原来的1.5倍</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK源码</title>
    <url>/2020/02/10/list/contentlist/</url>
    <content><![CDATA[<h1 id="简单集合框架"><a href="#简单集合框架" class="headerlink" title="简单集合框架"></a><table><tr><font color="#009100">简单集合框架</font></tr></table></h1><img src="/2020/02/10/list/contentlist/java_list.svg" class>

<h1 id="简单集合类"><a href="#简单集合类" class="headerlink" title="简单集合类"></a><table><tr><font color="#009100">简单集合类</font></tr></table></h1><ol>
<li><a href="../arraylist">ArrayList</a></li>
<li><a href="../linkedlist">LinkedList</a></li>
<li><a href="../hashmap">HashMap</a></li>
<li><a href="../linkedhashmap">LinkedHashMap</a></li>
<li><a href="../weakhashmap">WeakHashMap</a></li>
<li><a href="../treemap">TreeMap</a></li>
<li><a href="../identityhashmap">IdentityHashMap</a> </li>
<li><a href="../hashset">HashSet</a></li>
<li><a href="../linkedhashset">LinkedHashSet</a></li>
<li><a href="../hashtable">HashTable</a></li>
<li><a href="../treeset">TreeSet</a></li>
<li><a href="../properties">Properties</a></li>
<li><a href="../arraydeque">ArrayDeque</a></li>
</ol>
<h1 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a><table><tr><font color="#009100">并发集合类</font></tr></table></h1><ol>
<li><a href="../copyonWritearraylist">CopyOnWriteArrayList</a></li>
<li><a href="../concurrenthashmap">ConcurrentHashMap</a></li>
<li><a href="../copyonwritearrayset">CopyOnWriteArraySet</a></li>
<li><a href="../concurrentskiplistmap">ConcurrentSkipListMap</a></li>
<li><a href="../concurrentskiplistset">ConcurrentSkipListSet</a></li>
<li><a href="../arrayblockingqueue">ArrayBlockingQueue</a></li>
<li><a href="../linkedblockingqueue">LinkedBlockingQueue</a></li>
<li><a href="../linkedtransferqueue">LinkedTransferQueue</a></li>
<li><a href="../synchronousqueue">SynchronousQueue</a></li>
<li><a href="../priorityblockingqueue">PriorityBlockingQueue</a></li>
<li><a href="../concurrentlinkedqueue">ConcurrentLinkedQueue</a></li>
<li><a href="../delayqueue">DelayQueue</a></li>
<li><a href="../linkedblockingdeque">LinkedBlockingDeque</a></li>
<li><a href="../concurrentlinkeddeque">ConcurrentLinkedDeque</a></li>
</ol>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a><table><tr><font color="#009100">原子类</font></tr></table></h1><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a><table><tr><font color="#009100">同步</font></tr></table></h1><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a><table><tr><font color="#009100">线程</font></tr></table></h1>]]></content>
      <categories>
        <category>JDK源码目录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK源码</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap 源码</title>
    <url>/2020/02/10/list/hashmap/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><p>HashMap 是一个散列表，是 key/value 的存储结构，每个 key 对应唯一的一个 value，查询和修改的速度都很快；不能保证元素的存储顺序。<br>HashMap 的实现不是同步的，非线程安全。key 和 value 都可以为 null。<br>HashMap 的实例有两个参数影响性能：<strong>初始容量</strong> 和 <strong>加载因子</strong>。<br><strong>容量</strong> 是哈希表中桶的数量； <strong>初始容量</strong> 是哈希表在创建时的容量；<strong>加载因子</strong> 是哈希表在其容量自动增加之前可以达到多满的一种尺度。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/hashmap/hashmap.png" alt="HashMap 继承结构"></p>
<ul>
<li>HashMap 继承 <code>AbstractMap&lt;K,V&gt;</code>，实现 <code>Map</code> 接口。</li>
</ul>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a><table><tr><font color="#009100">存储结构</font></tr></table></h1><p><img src="/2020/02/10/list/hashmap/hashmap_structure.png" alt="HashMap 存储结构"></p>
<ul>
<li>HashMap 的实现采用了 <code>数组 + 链表 + 红黑树</code> 的复杂结构；</li>
<li>添加元素时，对 key 进行 hash 计算，根据 hash 值散列存储在数组中；</li>
<li>如果要存储的位置已经有元素存在了，则以链表的形式把元素存放在尾部；</li>
<li>如果数组的长度达到 64，且 链表 的长度也达到 8，则进行树化；</li>
<li>链表树化能大大地提高查询性能；<blockquote>
<p>数组的查询复杂度是 O(1)，链表的查询复杂度是 O(n)，红黑树的查询复杂度是 O(log n)；</p>
</blockquote>
</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>默认初始化容量 16（1 &lt;&lt; 4），最大容量为 2^30；</li>
<li>默认装载因子为 0.75，容量达到装载因子，则进行扩容；</li>
<li>当数组的容量达到 64 且链表的长度达到 8 的时候进行树化，当链表的长度小于 6 的时侯反树化；</li>
</ul>
<h2 id="Node内部类"><a href="#Node内部类" class="headerlink" title="Node内部类"></a>Node内部类</h2><p>Node 类是一个单向链表。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>

<p><strong>思考</strong></p>
<blockquote>
<p>为什么 hashCode 分别取 key 和 value 的 hashCode 求异或？（异或运算的妙用）<br><a href="https://blog.csdn.net/tongdanping/article/details/89322245" target="_blank" rel="noopener">相关文章</a></p>
</blockquote>
<h2 id="TreeNode-内部类"><a href="#TreeNode-内部类" class="headerlink" title="TreeNode 内部类"></a>TreeNode 内部类</h2><p>TreeNode是一个树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap 提供多个构造方法，供调用者设置初始化容量和加载因子。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>调用者没有指定初始化容量和加载因子，则使用默认的参数；</li>
<li>调用者初始化容量，通过 <code>tableSizeFor(int cap)</code> 方法把初始化容量设置为最近的 2^n；</li>
</ul>
<p><strong>思考</strong></p>
<blockquote>
<p>给定一个数，如何求出大于等于这个数，且最小的 2 的 n 次幂；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 数组容量为0，初始化数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// resize 初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// (n - 1) &amp; hash 计算元素在哪个桶中，如果桶没有元素，则直接保存</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 桶中已经有元素了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果桶中的 key 与待插入的 key 相等，则修改 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果是树节点，调用树的插入方法插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历链表，存在相同的 key 就修改 value，否则追加在链表末尾；如果复合树化规则，则树化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 触发树化检查，不一定就树化，还要检查数组的大小</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到相同 key 的元素，执行 value 的修改</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 移动元素节点到最后</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入元素后，转后续流程，可能移动到最大的位置</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>计算 key 的 hash 值：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> ；</li>
<li>如果数组的容量为 0，则初始化数组；元素在数组中的位置位置：<code>hash &amp; (size - 1)</code> ；</li>
<li>如果 key 不存在，则直接插入；如果插入的位置是数组，检查是否需要扩容；如果插入的位置是链表，检查是否需要树化；如果插入的位置是树，则检查是否需要做平衡；</li>
<li>如果 key 存在，则执行 value 修改；<blockquote>
<p>三种可能：</p>
<ol>
<li>key 存在于桶中，直接修改</li>
<li>key 存在于链表中，修改 value</li>
<li>key 存在于树中，修改 value，检查是否做平衡</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>思考</strong></p>
<blockquote>
<p>为什么 hashCode 如此设计？<br><a href="https://blog.csdn.net/qq_42034205/article/details/90384772" target="_blank" rel="noopener">相关文档</a></p>
</blockquote>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>扩容。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 达到最大容量，不再扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容后的容量没有超越最大容量，且大于默认初始化容量，则扩容为原来的2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果扩容门槛被设置为0，则计算为容量 * 装载因子，当不能超过最大容量</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置扩容门槛</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 创建新数组，开始复制操作</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 复制的元素没有下一个节点（不是链表和树），直接赋值</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果是树，则拆分成两棵树存放到桶中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果是链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 拆分成了两链表</span></span><br><span class="line">                    <span class="comment">// 低位链表在新桶中的位置一致</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 类中拆分树的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">    * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">    * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>数组的容量总是 2^n，每次扩容是原来的 2 倍；</li>
<li>根据加载因子计算扩容门槛，达到扩容门槛，则扩容；</li>
<li>最大容量不超过 2^30；</li>
<li>扩容中的数据复制分三种情况处理；<blockquote>
<ul>
<li>如果要复制的元素不是链表和树，直接引用；</li>
<li>如果要复制的元素是树，则拆分为两棵树放到桶中，低位树的位置跟旧数组中的位置一致，高位树的位置为 旧数组的容量 + 旧数组中的位置；</li>
<li>如果要复制的元素是链表，则拆分成两个链表，低位链表的位置跟旧数组中的一致，高位链表的位置为 旧数组的容量 + 旧数组中的位置；<br>  JDK8，这里顺序遍历，追加到链表尾部。JDK7没有使用红黑树，顺序遍历，添加在头部；并发场景下，转移数据扩容后，可能出现链表逆序，从而形成环型链表，造成死循环。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>思考</strong></p>
<blockquote>
<p>一个链表拆分成两个的算法为什么是 <code>(e.hash &amp; oldCap) == 0</code> ?<br><a href="https://blog.csdn.net/u010425839/article/details/106620440/" target="_blank" rel="noopener">相关文章</a></p>
</blockquote>
<h3 id="TreeNode-putTreeVal-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-int-h-K-k-V-v"><a href="#TreeNode-putTreeVal-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-int-h-K-k-V-v" class="headerlink" title="TreeNode.putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v)"></a>TreeNode.putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v)</h3><p>向红黑树中插入元素。</p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tree version of putVal.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 标记是否找到</span></span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 找到根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="comment">// dir = direction , 标记是左边还是右边</span></span><br><span class="line">        <span class="comment">// ph = p.hash , 当前节点的 hash 值</span></span><br><span class="line">        <span class="comment">// pk = p.key , 当前节点的 key 值</span></span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            <span class="comment">// 当前 hash 比目标 hash 大，在左边</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            <span class="comment">// 当前 hash 比目标 hash 小，在右边</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="comment">// 两者 hash 值相等，且 key 相等，说明找到该节点</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两者类型相同，再根据它们的内存地址计算hash值进行比较</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果最后确实没找到对应key的元素，则新建一个节点</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 插入树节点后平衡</span></span><br><span class="line">            <span class="comment">// 把root节点移动到链表的第一个节点</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>寻找根节点；</li>
<li>从根节点查找；</li>
<li>比较 hash 值及 key 值，如果相同，直接返回。在 putVal() 方法中决定是否要替换 value；</li>
<li>根据 hash 值及 key 值确定在树的左子树还是右子树查找，找到了直接返回；</li>
<li>如果最后没有找到则在树的相应位置插入元素，并做平衡；</li>
</ul>
<h3 id="treeifyBin-Node-lt-K-V-gt-tab-int-hash"><a href="#treeifyBin-Node-lt-K-V-gt-tab-int-hash" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab, int hash)"></a>treeifyBin(Node&lt;K,V&gt;[] tab, int hash)</h3><p>如果插入元素后链表的长度大于等于 8 则判断是否需要树化。</p>
<details>
<summary><font color="#009100"> View Code </font></summary>
<pre><code>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果桶数量小于64，扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 把所有节点换成树节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果进入过上面的循环，则从头节点开始树化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p></code></pre><p></p>
</details>

<h3 id="TreeNode-treeify-Node-lt-K-V-gt-tab"><a href="#TreeNode-treeify-Node-lt-K-V-gt-tab" class="headerlink" title="TreeNode.treeify(Node&lt;K,V&gt;[] tab)"></a>TreeNode.treeify(Node&lt;K,V&gt;[] tab)</h3><p>树化。</p>
<details>
<summary><font color="#009100"> View Code </font></summary>
<pre><code>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 第一个元素作为根节点，后面在做平衡</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p></code></pre><p></p>
</details>

<h3 id="TreeNode-removeTreeNode-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-boolean-movable"><a href="#TreeNode-removeTreeNode-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-boolean-movable" class="headerlink" title="TreeNode.removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable)"></a>TreeNode.removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable)</h3><details>
<summary><font color="#009100"> View Code </font></summary>
<pre><code>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">* This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">* cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">* successor that is pinned by "next" pointers that are accessible</span></span><br><span class="line"><span class="comment">* independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">* linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">* the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">* somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  节点在桶中的索引  </span></span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    <span class="comment">// 前置节点，后继节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 前置节点为空，当前位置是根节点。后继节点替换当前节点，删除了当前节点</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则把前置节点的下一个节点设置为当前节点的后继节点。相当于删除了当前节点。</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后继节点不为空，则后继节点的前置节点指向当前节点的前置节点，相当于删除了当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">        <span class="comment">// 无后继节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除红黑树中的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p></code></pre><p></p>
</details>

<ul>
<li>TreeNode 既是链表，也是红黑树；</li>
<li>先删除链表；</li>
<li>再删除红黑树，最后做平衡；</li>
</ul>
<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><details>
<summary><font color="#009100"> View Code </font></summary>
<pre><code>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 在数组中查找的第一个元素匹配上，则返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 在树中查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 在链表中查找</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p></code></pre><p></p>
</details>

<ul>
<li>计算 key 的 hash 值；</li>
<li>找到 key 所在的桶的第一个元素；</li>
<li>如果第一个元素的 key 等于待查找的 key，直接返回；</li>
<li>如果第一个元素是树节点，就按树的方式查找，否则按链表的方式查找；</li>
</ul>
<h3 id="TreeNode-getTreeNode-int-h-Object-k"><a href="#TreeNode-getTreeNode-int-h-Object-k" class="headerlink" title="TreeNode.getTreeNode(int h, Object k)"></a>TreeNode.getTreeNode(int h, Object k)</h3><details>
<summary><font color="#009100"> View Code </font></summary>
<pre><code>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calls find for root node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">* The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">* comparing keys.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="comment">// 找到则返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// hash相同，但key不同，左子树为空，查右子树</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 右子树为空，查左子树</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 比较 key 值大小，判断使用左子树还是右子树</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 以上条件都不通过，则尝试右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 都没有找到，左子树查找</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p></code></pre><p></p>
</details>

<ul>
<li>红黑树查找，先根据 hash 值比较，再根据 key 值比较决定查左子树还是右子树。</li>
</ul>
<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><details>
<summary><font color="#009100"> View Code </font></summary>
<pre><code>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 第一个元素是要找的目标元素，保存，然后删除使用</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 第一个元素是树节点，以树的方式查找</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是链表，则遍历查找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找到元素，匹配删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 树的方式删除</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 链表删除的，下一个个元素上移</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 数组删除</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除节点后处理</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p></code></pre><p></p>
</details>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>HashMap 是一种散列表，采用 <code>数组 + 链表 + 红黑树</code> 的存储结构；</li>
<li>HashMap 默认初始容量是 16，默认装载因子是 0.75f，容量总是 2 的 n 次方；</li>
<li>HashMap 每次扩容时，容量变为原来的两倍；</li>
<li>当数组的容量大于等于 64 且链表的长度大于 8 时，进行树化；</li>
<li>当单个桶的数据小于 6 时，进行反树化；</li>
</ul>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title=" FAQ "></a><table><tr><font color="#009100"> FAQ </font></tr></table></h1><p><strong>Q：HashMap 为什么用 数组 + 链表 + 红黑树 ？（实现原理）</strong></p>
<blockquote>
<ul>
<li>数组用来确定桶的位置；<br>key 的 hash 值：<code>(hash = key.hashCode()) ^ (hash &gt;&gt;&gt; 16)</code> ，桶在数组中的位置：<code>hash &amp; (size - 1)</code>；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>链表是解决 hash 冲突的一种方式；<br>如果元素所在的桶已经有元素了，以链表的方式追加在末尾；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>红黑树是解决链表查询性能的问题；<br>链表的查询时间复杂度是 O(n)，红黑树的查询时间复杂度是 O(log n)；当链表的长度大于 8，转成红黑树能大大提高查询性能；</li>
</ul>
</blockquote>
<p><strong>Q：HashMap 什么时候触发扩容？每次扩容的长度总是 2 的 n 次幂？</strong></p>
<blockquote>
<ul>
<li>如果数组大小达到 <code>(float)capacity * loadFactor</code>，就进行扩容；<br>默认加载因子为 0.75，最大容量不超过 2^30，每次扩容为原来的 2 倍，数组容量总是 2^n；</li>
<li>每次扩容是 2 的 n 次幂；<br>桶在数组中的位置为：<code>hash &amp; (size - 1)</code>，而 <code>size - 1</code> 转二进制，最高位为 0，低位全是 1，按位取与能减少 hash 碰撞；</li>
<li><strong>干扰函数</strong> 混合低位和高位，减少 hash 冲突：<code>(hash = key.hashCode()) ^ (hash &gt;&gt;&gt; 16)</code>；</li>
</ul>
</blockquote>
<p><strong>Q：String 中 hashcode 的实现？</strong></p>
<blockquote>
<p>用自然溢出等效取模：<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>；</p>
</blockquote>
<p><strong>Q：HashMap 扩容时每个 entry 需要再计算一次 Hash 吗？</strong></p>
<blockquote>
<p>不用 rehash，因为 HashMap 在扩容量、HashCode 和 数组索引位置计算上做了巧妙的设计，扩容后的元素，分高低位，低位保持原来数组索引的位置，而高位为原来的位置+扩容 size，所以不用 rehash；</p>
</blockquote>
<p><strong>Q：HashMap 中元素的位置计算应用了 key.hashCode()，重写 hashcode 和 equals 要方法注意什么?</strong></p>
<blockquote>
<p>四个原则（存在 hash 碰撞）：</p>
<ul>
<li>两个对象相等，hashcode 一定相等 </li>
<li>两个对象不等，hashcode 不一定不等 </li>
<li>hashcode 相等，两个对象不一定相等 </li>
<li>hashcode 不等，两个对象一定不等</li>
</ul>
</blockquote>
<p><strong>Q：HashMap 的同步实现？</strong></p>
<blockquote>
<p><code>Map m = Collections.synchronizeMap(hashMap)</code></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashTable 源码</title>
    <url>/2020/02/10/list/hashtable/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ol>
<li>HashTable 允许 null 吗？</li>
<li>HashTable 是线程安全的吗？如何实现的？</li>
</ol>
<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><table><tr><font color="#009100">概括</font></tr></table></h1><p>HashTable 是一个散列表，它存储的内容是键值对（key-value）映射。HashTable 是线程安全的、无序的，key 和 value 都不可以为 null。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet 源码</title>
    <url>/2020/02/10/list/hashset/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ol>
<li>HashSet 底层数据结构是什么？</li>
<li>HashSet 是有序的吗？</li>
<li>HashSet 是否允许 null 元素？</li>
</ol>
<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><table><tr><font color="#009100">概括</font></tr></table></h1><p>HashSet 是 Set 的一种实现方式，基于 HashMap 来确保元素不重复。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/hashset/hashset.png" alt="HashSet 继承结构"></p>
<ul>
<li>实现 Set 接口，有 Set 所有特性</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>HashSet 的底层是基于 HashMap 实现；</li>
<li>PRESENT 伪值，以便与后备映射中的对象相关联；</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment"> * the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set.  (This package private</span></span><br><span class="line"><span class="comment"> * constructor is only used by LinkedHashSet.) The backing</span></span><br><span class="line"><span class="comment"> * HashMap instance is a LinkedHashMap with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dummy             ignored (distinguishes this</span></span><br><span class="line"><span class="comment"> *             constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>初始化过程，实际上是初始化 HashMap 参数；</li>
<li>最后一个构造方法是 LinkedHashSet 专属的方法；</li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span></span><br><span class="line"><span class="comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> * element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>增加元素，实际上是把元素作为 key 保存到 HashMap 中，而对应的 Value 是一个空对象数组；</li>
</ul>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the specified element from this set if it is present.</span></span><br><span class="line"><span class="comment"> * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * if this set contains such an element.  Returns &lt;tt&gt;true&lt;/tt&gt; if</span></span><br><span class="line"><span class="comment"> * this set contained the element (or equivalently, if this set</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).  (This set will not contain the</span></span><br><span class="line"><span class="comment"> * element once the call returns.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o object to be removed from this set, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>删除元素的同时，对 value 做了一次判断；</li>
</ul>
<h3 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set</span></span><br><span class="line"><span class="comment"> * contains an element &lt;tt&gt;e&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this set is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>判断集合是否包含某一元素，直接调用 HashMap.containsKey(o) 方法；</li>
</ul>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an iterator over the elements in this set.  The elements</span></span><br><span class="line"><span class="comment"> * are returned in no particular order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an Iterator over the elements in this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>遍历元素也是直接调用 HashMap 方法；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>HashSet 内部使用 HashMap 的 key 存储元素，以此来保证元素不重复；</li>
<li>HashSet 是无序的，因为 HashMap 的 key 是无序的；</li>
<li>HashSet 中允许有一个 null 元素，因为 HashMap 允许 key 为 null；</li>
<li>HashSet 是非线程安全的；</li>
<li>HashSet 是没有 get() 方法的；</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap 源码</title>
    <url>/2020/02/10/list/linkedhashmap/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ol>
<li>如何用 LinkedHashMap 实现LRU？</li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><p>LinkedHashMap 内部维护了一个双向链表，能保证元素按照插入顺序访问，也能以访问顺序访问。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/linkedhashmap/linkedhashmap.png" alt="LinkedHashMap继承结构"></p>
<ul>
<li>LinkedHashMap 继承了 <code>HashMap</code> 的特性</li>
</ul>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><p><code>head</code></p>
<blockquote>
<p>双向链表头节点，旧数据存在头节点</p>
</blockquote>
</li>
<li><p><code>tail</code></p>
<blockquote>
<p>双向链表尾节点，新数据存在尾节点</p>
</blockquote>
</li>
<li><p><code>accessOrder</code></p>
<blockquote>
<p>是否按照访问顺序排序，<code>true</code> 按照访问顺序存储元素， <code>false</code> 按照插入顺序存储元素</p>
</blockquote>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>存储节点，继承自 <code>HashMap</code> 的 <code>Node</code> 类，<code>before</code> 和 <code>after</code> 用于双向链表存储前后元素</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the specified initial capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the specified initial capacity and a default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with</span></span><br><span class="line"><span class="comment"> * the same mappings as the specified map.  The &lt;tt&gt;LinkedHashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * instance is created with a default load factor (0.75) and an initial</span></span><br><span class="line"><span class="comment"> * capacity sufficient to hold the mappings in the specified map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment"> * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment"> *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>构造方法默认 <code>accessOrder = false</code>, 按照插入顺序访问；最后一个构造方法，可设置存储顺序，进而实现 LRU </li>
</ul>
<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a><table><tr><font color="#009100">操作方法</font></tr></table></h1><h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>查找元素，如果 <code>accessOrder = true</code>, 把访问的元素移动到双向链表的末尾</li>
</ul>
<h2 id="afterNodeInsertion-boolean-evict"><a href="#afterNodeInsertion-boolean-evict" class="headerlink" title="afterNodeInsertion(boolean evict)"></a>afterNodeInsertion(boolean evict)</h2><p>插入元素后，如果设置驱逐参数 <code>evict = true</code>，则执行 </p>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry.</span></span><br><span class="line"><span class="comment"> * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after</span></span><br><span class="line"><span class="comment"> * inserting a new entry into the map.  It provides the implementor</span></span><br><span class="line"><span class="comment"> * with the opportunity to remove the eldest entry each time a new one</span></span><br><span class="line"><span class="comment"> * is added.  This is useful if the map represents a cache: it allows</span></span><br><span class="line"><span class="comment"> * the map to reduce memory consumption by deleting stale entries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Sample use: this override will allow the map to grow up to 100</span></span><br><span class="line"><span class="comment"> * entries and then delete the eldest entry each time a new entry is</span></span><br><span class="line"><span class="comment"> * added, maintaining a steady state of 100 entries.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     private static final int MAX_ENTRIES = 100;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span></span><br><span class="line"><span class="comment"> *        return size() &amp;gt; MAX_ENTRIES;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method typically does not modify the map in any way,</span></span><br><span class="line"><span class="comment"> * instead allowing the map to modify itself as directed by its</span></span><br><span class="line"><span class="comment"> * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span></span><br><span class="line"><span class="comment"> * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;false&lt;/tt&gt; (indicating that the map should not attempt any</span></span><br><span class="line"><span class="comment"> * further modification).  The effects of returning &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * after modifying the map from within this method are unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation merely returns &lt;tt&gt;false&lt;/tt&gt; (so that this</span></span><br><span class="line"><span class="comment"> * map acts like a normal map - the eldest element is never removed).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>    eldest The least recently inserted entry in the map, or if</span></span><br><span class="line"><span class="comment"> *           this is an access-ordered map, the least recently accessed</span></span><br><span class="line"><span class="comment"> *           entry.  This is the entry that will be removed it this</span></span><br><span class="line"><span class="comment"> *           method returns &lt;tt&gt;true&lt;/tt&gt;.  If the map was empty prior</span></span><br><span class="line"><span class="comment"> *           to the &lt;tt&gt;put&lt;/tt&gt; or &lt;tt&gt;putAll&lt;/tt&gt; invocation resulting</span></span><br><span class="line"><span class="comment"> *           in this invocation, this will be the entry that was just</span></span><br><span class="line"><span class="comment"> *           inserted; in other words, if the map contains a single</span></span><br><span class="line"><span class="comment"> *           entry, the eldest entry is also the newest.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   &lt;tt&gt;true&lt;/tt&gt; if the eldest entry should be removed</span></span><br><span class="line"><span class="comment"> *           from the map; &lt;tt&gt;false&lt;/tt&gt; if it should be retained.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><code>evict = true</code>，且头部节点不为空，调用 <code>HashMap.removeNode</code> 方法把头节点移除</li>
<li><code>HashMap.removeNode</code>方法执行完后，会调用 <code>afterNodeRemoval(Node&lt;K,V&gt; e)</code> 方法，修改双向链表的头部和尾部</li>
<li><code>HashMap.removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code> 方法默认不删除元素，如果要实现 LRU 需重写该方法</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>LinkedHashMap 继承自 HashMap，具有 HashMap 的所有特性；</li>
<li>LinkedHashMap 内部维护了一个双向链表，存储所有元素；</li>
<li><code>accessOrder = false</code>，按照插入顺序存储，否则按照访问顺序存储；默认为 <code>false</code>；</li>
<li>LinkedHashMap 默认不删除旧元素，如果要删除，需重写 <code>removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法；</li>
</ul>
<h1 id="实现一个-LRU"><a href="#实现一个-LRU" class="headerlink" title="实现一个 LRU"></a><table><tr><font color="#009100">实现一个 LRU</font></tr></table></h1><ul>
<li>LRU 是最近最少使用（Leates Recently Used），优先淘汰最近最少使用的元素</li>
<li>LinkedHashMap 设置 <code>accessOrder = true</code>，按照访问顺序存储</li>
<li>重写 <code>removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)</code> 方法，设置元素删除机制</li>
</ul>
<details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="keyword">this</span>.capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList 源码</title>
    <url>/2020/02/10/list/linkedlist/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><table><tr><font color="#009100">问题</font></tr></table></h1><ol>
<li>LinkedList 与 ArrayList 的区别是什么？</li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><table><tr><font color="#009100">概述</font></tr></table></h1><p>LinkedList 是一个双向链表实现的集合，除了作为普通集合使用，它还可以作为队列或者栈来使用。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/linkedlist/linkedlist.png" alt="LinkedList 继承结构"></p>
<ul>
<li>实现了 <code>List&lt;E&gt;</code> 接口</li>
</ul>
<blockquote>
<p>可作为 List 集合使用</p>
</blockquote>
<ul>
<li>实现了 <code>Deque&lt;E&gt;</code> 接口</li>
</ul>
<blockquote>
<p>可作为双端队列、栈使用</p>
</blockquote>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a><table><tr><font color="#009100">源码实现</font></tr></table></h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义元素个数，链表的首尾节点</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>Node 是一个双向链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个构造方法，无界队列。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="首尾添加元素"><a href="#首尾添加元素" class="headerlink" title="首尾添加元素"></a>首尾添加元素</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as first element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque operations</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerFirst&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Deque#offerLast&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>前后添加元素相对简单，创建 Node 对象，设置前后指针。</p>
<h3 id="中间添加元素"><a href="#中间添加元素" class="headerlink" title="中间添加元素"></a>中间添加元素</h3><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>找到对应位置的元素</li>
<li>添加新元素，并设置新元素的前后元素</li>
</ul>
<p>中间插入元素的时间复杂度是O(n)</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><h3 id="首尾删除元素"><a href="#首尾删除元素" class="headerlink" title="首尾删除元素"></a>首尾删除元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移动首部或者尾部指针；</li>
<li>将原来的元素位置置为null，释放空间；</li>
</ul>
<h3 id="中间删除元素"><a href="#中间删除元素" class="headerlink" title="中间删除元素"></a>中间删除元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果元素在头部或尾部，走首尾删除元素的流程；</li>
<li>如果元素在中间，设置元素前后的指针；</li>
<li>改变删除的元素指针，并置为null，释放空间；</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #removeFirst()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the front of this list (which is the top</span></span><br><span class="line"><span class="comment"> *         of the stack represented by this list)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>push(E e)</code> 和 <code>pop()</code> 方法；</li>
<li>实现 LIFO(Last In First Out) 栈功能；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>LinkedList 是一个双向链表实现的集合；</li>
<li>LinkedList 还是一个双端队列，可实现栈；</li>
<li>LinkedList 不支持随机访问，访问非队列首尾元素效率比较低；</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Properties 源码</title>
    <url>/2020/02/10/list/properties/</url>
    <content><![CDATA[<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a><table><tr><font color="#009100">概括</font></tr></table></h1><p>Properties 继承 Hashtable ，是线程安全的，主要用于读取配置文件。</p>
<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><table><tr><font color="#009100">继承结构</font></tr></table></h1><p><img src="/2020/02/10/list/properties/properties.png" alt="Properties继承结构"></p>
<ul>
<li>继承 Hashtable，是线程安全的；</li>
<li>实现 Map 接口，有 Map 的属性；</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A property list that contains default values for any keys not</span></span><br><span class="line"><span class="comment"> * found in this property list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Properties defaults;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an empty property list with no default values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Properties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an empty property list with the specified defaults.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   defaults   the defaults.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Properties</span><span class="params">(Properties defaults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaults = defaults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>初始化 Properties 设定默认值；</li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A natural line that contains only white space characters is</span></span><br><span class="line"><span class="comment"> * considered blank and is ignored.  A comment line has an ASCII</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> '#'&#125; or &#123;<span class="doctag">@code</span> '!'&#125; as its first non-white</span></span><br><span class="line"><span class="comment"> * space character; comment lines are also ignored and do not</span></span><br><span class="line"><span class="comment"> * encode key-element information.  In addition to line</span></span><br><span class="line"><span class="comment"> * terminators, this format considers the characters space</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@code</span> ' '&#125;, &#123;<span class="doctag">@code</span> '\u005Cu0020'&#125;), tab</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@code</span> '\t'&#125;, &#123;<span class="doctag">@code</span> '\u005Cu0009'&#125;), and form feed</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@code</span> '\f'&#125;, &#123;<span class="doctag">@code</span> '\u005Cu000C'&#125;) to be white</span></span><br><span class="line"><span class="comment"> * space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The key contains all of the characters in the line starting</span></span><br><span class="line"><span class="comment"> * with the first non-white space character and up to, but not</span></span><br><span class="line"><span class="comment"> * including, the first unescaped &#123;<span class="doctag">@code</span> '='&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ':'&#125;, or white space character other than a line</span></span><br><span class="line"><span class="comment"> * terminator. All of these key termination characters may be</span></span><br><span class="line"><span class="comment"> * included in the key by escaping them with a preceding backslash</span></span><br><span class="line"><span class="comment"> * character; for example,&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> \:\=&#125;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * would be the two-character key &#123;<span class="doctag">@code</span> ":="&#125;.  Line</span></span><br><span class="line"><span class="comment"> * terminator characters can be included using &#123;<span class="doctag">@code</span> \r&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> \n&#125; escape sequences.  Any white space after the</span></span><br><span class="line"><span class="comment"> * key is skipped; if the first non-white space character after</span></span><br><span class="line"><span class="comment"> * the key is &#123;<span class="doctag">@code</span> '='&#125; or &#123;<span class="doctag">@code</span> ':'&#125;, then it is</span></span><br><span class="line"><span class="comment"> * ignored and any white space characters after it are also</span></span><br><span class="line"><span class="comment"> * skipped.  All remaining characters on the line become part of</span></span><br><span class="line"><span class="comment"> * the associated element string; if there are no remaining</span></span><br><span class="line"><span class="comment"> * characters, the element is the empty string</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ""&#125;.  Once the raw character sequences</span></span><br><span class="line"><span class="comment"> * constituting the key and element are identified, escape</span></span><br><span class="line"><span class="comment"> * processing is performed as described above.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * As an example, each of the following three lines specifies the key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "Truth"&#125; and the associated element value</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "Beauty"&#125;:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Truth = Beauty</span></span><br><span class="line"><span class="comment"> *  Truth:Beauty</span></span><br><span class="line"><span class="comment"> * Truth                    :Beauty</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * As another example, the following three lines specify a single</span></span><br><span class="line"><span class="comment"> * property:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * fruits                           apple, banana, pear, \</span></span><br><span class="line"><span class="comment"> *                                  cantaloupe, watermelon, \</span></span><br><span class="line"><span class="comment"> *                                  kiwi, mango</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * The key is &#123;<span class="doctag">@code</span> "fruits"&#125; and the associated element is:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;"apple, banana, pear, cantaloupe, watermelon, kiwi, mango"&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * Note that a space appears before each &#123;<span class="doctag">@code</span> \&#125; so that a space</span></span><br><span class="line"><span class="comment"> * will appear after each comma in the final result; the &#123;<span class="doctag">@code</span> \&#125;,</span></span><br><span class="line"><span class="comment"> * line terminator, and leading white space on the continuation line are</span></span><br><span class="line"><span class="comment"> * merely discarded and are &lt;i&gt;not&lt;/i&gt; replaced by one or more other</span></span><br><span class="line"><span class="comment"> * characters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * As a third example, the line:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;cheeses</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * specifies that the key is &#123;<span class="doctag">@code</span> "cheeses"&#125; and the associated</span></span><br><span class="line"><span class="comment"> * element is the empty string &#123;<span class="doctag">@code</span> ""&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;a name="unicodeescapes"&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Characters in keys and elements can be represented in escape</span></span><br><span class="line"><span class="comment"> * sequences similar to those used for character and string literals</span></span><br><span class="line"><span class="comment"> * (see sections 3.3 and 3.10.6 of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The differences from the character escape sequences and Unicode</span></span><br><span class="line"><span class="comment"> * escapes used for characters and strings are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; Octal escapes are not recognized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The character sequence &#123;<span class="doctag">@code</span> \b&#125; does &lt;i&gt;not&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * represent a backspace character.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The method does not treat a backslash character,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> \&#125;, before a non-valid escape character as an</span></span><br><span class="line"><span class="comment"> * error; the backslash is silently dropped.  For example, in a</span></span><br><span class="line"><span class="comment"> * Java string the sequence &#123;<span class="doctag">@code</span> "\z"&#125; would cause a</span></span><br><span class="line"><span class="comment"> * compile time error.  In contrast, this method silently drops</span></span><br><span class="line"><span class="comment"> * the backslash.  Therefore, this method treats the two character</span></span><br><span class="line"><span class="comment"> * sequence &#123;<span class="doctag">@code</span> "\b"&#125; as equivalent to the single</span></span><br><span class="line"><span class="comment"> * character &#123;<span class="doctag">@code</span> 'b'&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The specified stream remains open after this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   reader   the input character stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IOException  if an error occurred when reading from the</span></span><br><span class="line"><span class="comment"> *          input stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException if a malformed Unicode escape</span></span><br><span class="line"><span class="comment"> *          appears in the input.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Reader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Reader 加载</span></span><br><span class="line">    load0(<span class="keyword">new</span> LineReader(reader));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads a property list (key and element pairs) from the input</span></span><br><span class="line"><span class="comment"> * byte stream. The input stream is in a simple line-oriented</span></span><br><span class="line"><span class="comment"> * format as specified in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #load(java.io.Reader) load(Reader)&#125; and is assumed to use</span></span><br><span class="line"><span class="comment"> * the ISO 8859-1 character encoding; that is each byte is one Latin1</span></span><br><span class="line"><span class="comment"> * character. Characters not in Latin1, and certain special characters,</span></span><br><span class="line"><span class="comment"> * are represented in keys and elements using Unicode escapes as defined in</span></span><br><span class="line"><span class="comment"> * section 3.3 of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The specified stream remains open after this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      inStream   the input stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IOException  if an error occurred when reading from the</span></span><br><span class="line"><span class="comment"> *             input stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the input stream contains a</span></span><br><span class="line"><span class="comment"> *             malformed Unicode escape sequence.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream inStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 输入流加载</span></span><br><span class="line">    load0(<span class="keyword">new</span> LineReader(inStream));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load0</span> <span class="params">(LineReader lr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] convtBuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">int</span> keyLen;</span><br><span class="line">    <span class="keyword">int</span> valueStart;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="comment">// 是否有空格</span></span><br><span class="line">    <span class="keyword">boolean</span> hasSep;</span><br><span class="line">    <span class="comment">// 是否有前反斜杠</span></span><br><span class="line">    <span class="keyword">boolean</span> precedingBackslash;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((limit = lr.readLine()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        keyLen = <span class="number">0</span>;</span><br><span class="line">        valueStart = limit;</span><br><span class="line">        hasSep = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("line=&lt;" + new String(lineBuf, 0, limit) + "&gt;");</span></span><br><span class="line">        precedingBackslash = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (keyLen &lt; limit) &#123;</span><br><span class="line">            c = lr.lineBuf[keyLen];</span><br><span class="line">            <span class="comment">//need check if escaped.</span></span><br><span class="line">            <span class="keyword">if</span> ((c == <span class="string">'='</span> ||  c == <span class="string">':'</span>) &amp;&amp; !precedingBackslash) &#123;</span><br><span class="line">                <span class="comment">// 当前字符是 '=' 或者是 ':'，且没有反斜杠</span></span><br><span class="line">                valueStart = keyLen + <span class="number">1</span>;</span><br><span class="line">                hasSep = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c == <span class="string">' '</span> || c == <span class="string">'\t'</span> ||  c == <span class="string">'\f'</span>) &amp;&amp; !precedingBackslash) &#123;</span><br><span class="line">                <span class="comment">// 空格、制表符、换页，且没有反斜杠</span></span><br><span class="line">                valueStart = keyLen + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\\'</span>) &#123;</span><br><span class="line">                <span class="comment">// 反斜杠</span></span><br><span class="line">                precedingBackslash = !precedingBackslash;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                precedingBackslash = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            keyLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (valueStart &lt; limit) &#123;</span><br><span class="line">            c = lr.lineBuf[valueStart];</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">' '</span> &amp;&amp; c != <span class="string">'\t'</span> &amp;&amp;  c != <span class="string">'\f'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasSep &amp;&amp; (c == <span class="string">'='</span> ||  c == <span class="string">':'</span>)) &#123;</span><br><span class="line">                    hasSep = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            valueStart++;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = loadConvert(lr.lineBuf, <span class="number">0</span>, keyLen, convtBuf);</span><br><span class="line">        String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf);</span><br><span class="line">        put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Writes this property list (key and element pairs) in this</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Properties&#125; table to the output stream in a format suitable</span></span><br><span class="line"><span class="comment"> * for loading into a &#123;<span class="doctag">@code</span> Properties&#125; table using the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #load(InputStream) load(InputStream)&#125; method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Properties from the defaults table of this &#123;<span class="doctag">@code</span> Properties&#125;</span></span><br><span class="line"><span class="comment"> * table (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method outputs the comments, properties keys and values in</span></span><br><span class="line"><span class="comment"> * the same format as specified in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #store(java.io.Writer, java.lang.String) store(Writer)&#125;,</span></span><br><span class="line"><span class="comment"> * with the following differences:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The stream is written using the ISO 8859-1 character encoding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Characters not in Latin-1 in the comments are written as</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> \u005Cu&#125;&lt;i&gt;xxxx&lt;/i&gt; for their appropriate unicode</span></span><br><span class="line"><span class="comment"> * hexadecimal value &lt;i&gt;xxxx&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Characters less than &#123;<span class="doctag">@code</span> \u005Cu0020&#125; and characters greater</span></span><br><span class="line"><span class="comment"> * than &#123;<span class="doctag">@code</span> \u005Cu007E&#125; in property keys or values are written</span></span><br><span class="line"><span class="comment"> * as &#123;<span class="doctag">@code</span> \u005Cu&#125;&lt;i&gt;xxxx&lt;/i&gt; for the appropriate hexadecimal</span></span><br><span class="line"><span class="comment"> * value &lt;i&gt;xxxx&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * After the entries have been written, the output stream is flushed.</span></span><br><span class="line"><span class="comment"> * The output stream remains open after this method returns.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   out      an output stream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   comments   a description of the property list.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IOException if writing this property list to the specified</span></span><br><span class="line"><span class="comment"> *             output stream throws an &lt;tt&gt;IOException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  ClassCastException  if this &#123;<span class="doctag">@code</span> Properties&#125; object</span></span><br><span class="line"><span class="comment"> *             contains any keys or values that are not &#123;<span class="doctag">@code</span> Strings&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  NullPointerException  if &#123;<span class="doctag">@code</span> out&#125; is null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out, String comments)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    store0(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out, <span class="string">"8859_1"</span>)),</span><br><span class="line">           comments,</span><br><span class="line">           <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">store0</span><span class="params">(BufferedWriter bw, String comments, <span class="keyword">boolean</span> escUnicode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comments != <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeComments(bw, comments);</span><br><span class="line">    &#125;</span><br><span class="line">    bw.write(<span class="string">"#"</span> + <span class="keyword">new</span> Date().toString());</span><br><span class="line">    bw.newLine();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Enumeration&lt;?&gt; e = keys(); e.hasMoreElements();) &#123;</span><br><span class="line">            String key = (String)e.nextElement();</span><br><span class="line">            String val = (String)get(key);</span><br><span class="line">            key = saveConvert(key, <span class="keyword">true</span>, escUnicode);</span><br><span class="line">            <span class="comment">/* No need to escape embedded and trailing spaces for value, hence</span></span><br><span class="line"><span class="comment">             * pass false to flag.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            val = saveConvert(val, <span class="keyword">false</span>, escUnicode);</span><br><span class="line">            bw.write(key + <span class="string">"="</span> + val);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>读取文本中的内容，根据特殊符号分割。保存属性内容，load 方法调用时加载出保存的数据；</p>
<h2 id="XML内容加载和保存"><a href="#XML内容加载和保存" class="headerlink" title="XML内容加载和保存"></a>XML内容加载和保存</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads all of the properties represented by the XML document on the</span></span><br><span class="line"><span class="comment"> * specified input stream into this properties table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The XML document must have the following DOCTYPE declaration:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * &amp;lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&amp;gt;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * Furthermore, the document must satisfy the properties DTD described</span></span><br><span class="line"><span class="comment"> * above.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An implementation is required to read XML documents that use the</span></span><br><span class="line"><span class="comment"> * "&#123;<span class="doctag">@code</span> UTF-8&#125;" or "&#123;<span class="doctag">@code</span> UTF-16&#125;" encoding. An implementation may</span></span><br><span class="line"><span class="comment"> * support additional encodings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The specified stream is closed after this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in the input stream from which to read the XML document.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if reading from the specified input stream</span></span><br><span class="line"><span class="comment"> *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.UnsupportedEncodingException if the document's encoding</span></span><br><span class="line"><span class="comment"> *         declaration can be read and it specifies an encoding that is not</span></span><br><span class="line"><span class="comment"> *         supported</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidPropertiesFormatException Data on input stream does not</span></span><br><span class="line"><span class="comment"> *         constitute a valid XML document with the mandated document type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> in&#125; is null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    #storeToXML(OutputStream, String, String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    &lt;a href="http://www.w3.org/TR/REC-xml/#charencoding"&gt;Character</span></span><br><span class="line"><span class="comment"> *         Encoding in Entities&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadFromXML</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, InvalidPropertiesFormatException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XmlSupport.load(<span class="keyword">this</span>, Objects.requireNonNull(in));</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Emits an XML document representing all of the properties contained</span></span><br><span class="line"><span class="comment"> * in this table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;props.storeToXML(os,</span></span><br><span class="line"><span class="comment"> * comment)&lt;/tt&gt; behaves in exactly the same way as the invocation</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;props.storeToXML(os, comment, "UTF-8");&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> os the output stream on which to emit the XML document.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comment a description of the property list, or &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> *        if no comment is desired.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if writing to the specified output stream</span></span><br><span class="line"><span class="comment"> *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> os&#125; is null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException  if this &#123;<span class="doctag">@code</span> Properties&#125; object</span></span><br><span class="line"><span class="comment"> *         contains any keys or values that are not</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> Strings&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    #loadFromXML(InputStream)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeToXML</span><span class="params">(OutputStream os, String comment)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    storeToXML(os, comment, <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Emits an XML document representing all of the properties contained</span></span><br><span class="line"><span class="comment"> * in this table, using the specified encoding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The XML document will have the following DOCTYPE declaration:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * &amp;lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&amp;gt;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified comment is &#123;<span class="doctag">@code</span> null&#125; then no comment</span></span><br><span class="line"><span class="comment"> * will be stored in the document.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An implementation is required to support writing of XML documents</span></span><br><span class="line"><span class="comment"> * that use the "&#123;<span class="doctag">@code</span> UTF-8&#125;" or "&#123;<span class="doctag">@code</span> UTF-16&#125;" encoding. An</span></span><br><span class="line"><span class="comment"> * implementation may support additional encodings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The specified stream remains open after this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> os        the output stream on which to emit the XML document.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comment   a description of the property list, or &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> *                  if no comment is desired.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  encoding the name of a supported</span></span><br><span class="line"><span class="comment"> *                  &lt;a href="../lang/package-summary.html#charenc"&gt;</span></span><br><span class="line"><span class="comment"> *                  character encoding&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if writing to the specified output stream</span></span><br><span class="line"><span class="comment"> *         results in an &lt;tt&gt;IOException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.io.UnsupportedEncodingException if the encoding is not</span></span><br><span class="line"><span class="comment"> *         supported by the implementation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> os&#125; is &#123;<span class="doctag">@code</span> null&#125;,</span></span><br><span class="line"><span class="comment"> *         or if &#123;<span class="doctag">@code</span> encoding&#125; is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException  if this &#123;<span class="doctag">@code</span> Properties&#125; object</span></span><br><span class="line"><span class="comment"> *         contains any keys or values that are not</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> Strings&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    #loadFromXML(InputStream)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    &lt;a href="http://www.w3.org/TR/REC-xml/#charencoding"&gt;Character</span></span><br><span class="line"><span class="comment"> *         Encoding in Entities&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeToXML</span><span class="params">(OutputStream os, String comment, String encoding)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XmlSupport.save(<span class="keyword">this</span>, Objects.requireNonNull(os), comment,</span><br><span class="line">                    Objects.requireNonNull(encoding));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>XML 文本读取和保存操作；</li>
<li>使用 jdk.internal.util.xml.BasicXmlPropertiesProvider 类实现；</li>
</ul>
<h2 id="Properties-属性的使用"><a href="#Properties-属性的使用" class="headerlink" title="Properties 属性的使用"></a>Properties 属性的使用</h2><details>
    <summary><font color="#009100"> View Code </font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Searches for the property with the specified key in this property list.</span></span><br><span class="line"><span class="comment"> * If the key is not found in this property list, the default property list,</span></span><br><span class="line"><span class="comment"> * and its defaults, recursively, are then checked. The method returns the</span></span><br><span class="line"><span class="comment"> * default value argument if the property is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   key            the hashtable key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   defaultValue   a default value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the value in this property list with the specified key value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #setProperty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #defaults</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span> </span>&#123;</span><br><span class="line">    String val = getProperty(key);</span><br><span class="line">    <span class="keyword">return</span> (val == <span class="keyword">null</span>) ? defaultValue : val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an enumeration of all the keys in this property list,</span></span><br><span class="line"><span class="comment"> * including distinct keys in the default property list if a key</span></span><br><span class="line"><span class="comment"> * of the same name has not already been found from the main</span></span><br><span class="line"><span class="comment"> * properties list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  an enumeration of all the keys in this property list, including</span></span><br><span class="line"><span class="comment"> *          the keys in the default property list.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassCastException if any key in this property list</span></span><br><span class="line"><span class="comment"> *          is not a string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.Enumeration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.Properties#defaults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #stringPropertyNames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;?&gt; propertyNames() &#123;</span><br><span class="line">    Hashtable&lt;String,Object&gt; h = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    enumerate(h);</span><br><span class="line">    <span class="keyword">return</span> h.keys();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a set of keys in this property list where</span></span><br><span class="line"><span class="comment"> * the key and its corresponding value are strings,</span></span><br><span class="line"><span class="comment"> * including distinct keys in the default property list if a key</span></span><br><span class="line"><span class="comment"> * of the same name has not already been found from the main</span></span><br><span class="line"><span class="comment"> * properties list.  Properties whose key or value is not</span></span><br><span class="line"><span class="comment"> * of type &lt;tt&gt;String&lt;/tt&gt; are omitted.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The returned set is not backed by the &lt;tt&gt;Properties&lt;/tt&gt; object.</span></span><br><span class="line"><span class="comment"> * Changes to this &lt;tt&gt;Properties&lt;/tt&gt; are not reflected in the set,</span></span><br><span class="line"><span class="comment"> * or vice versa.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a set of keys in this property list where</span></span><br><span class="line"><span class="comment"> *          the key and its corresponding value are strings,</span></span><br><span class="line"><span class="comment"> *          including the keys in the default property list.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.Properties#defaults</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">stringPropertyNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Hashtable&lt;String, String&gt; h = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    enumerateStringProperties(h);</span><br><span class="line">    <span class="keyword">return</span> h.keySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Searches for the property with the specified key in this property list.</span></span><br><span class="line"><span class="comment"> * If the key is not found in this property list, the default property list,</span></span><br><span class="line"><span class="comment"> * and its defaults, recursively, are then checked. The method returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; if the property is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   key   the property key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the value in this property list with the specified key value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #setProperty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #defaults</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Object oval = <span class="keyword">super</span>.get(key);</span><br><span class="line">    String sval = (oval <span class="keyword">instanceof</span> String) ? (String)oval : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ((sval == <span class="keyword">null</span>) &amp;&amp; (defaults != <span class="keyword">null</span>)) ? defaults.getProperty(key) : sval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enumerates all key/value pairs in the specified hashtable</span></span><br><span class="line"><span class="comment"> * and omits the property if the key or value is not a string.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h the hashtable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enumerateStringProperties</span><span class="params">(Hashtable&lt;String, String&gt; h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaults.enumerateStringProperties(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Enumeration&lt;?&gt; e = keys() ; e.hasMoreElements() ;) &#123;</span><br><span class="line">        Object k = e.nextElement();</span><br><span class="line">        Object v = get(k);</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String &amp;&amp; v <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            h.put((String) k, (String) v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>属性读取，从 Hashtable 中取值；</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ul>
<li>Properties 主要用于配置文件的加载，是线程安全的；</li>
<li>Properties 的核心功能主要有两个：<blockquote>
<ul>
<li>.properties 文本配置信息读取</li>
<li>.xml 文本配置读取</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Properties</tag>
      </tags>
  </entry>
</search>
