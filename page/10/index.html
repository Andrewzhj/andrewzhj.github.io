<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Andrew 的笔记
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="Andrew 的笔记" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <!-- <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a> -->
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
        
      <div id="subtitle-box">
        
          <!-- <span id="subtitle"><p>无论走到哪里，<br> 都应该记住，<br> 过去都是假的，<br> 回忆是一条没有尽头的路。<br> 一切以往的春天都不复存在，<br> 就连那最坚韧而又狂乱的爱情，<br> 归根结底也不过是转瞬即逝的现实，<br> 唯有孤独永恒。<br> ——加西亚·马尔克斯 </p></span> -->
          <span id="subtitle">
            <p style="text-align: left;">无论走到哪里，<br>
              都应该记住，<br>
              过去都是假的，<br>
              回忆是一条没有尽头的路。<br>
              一切以往的春天都不复存在，<br>
              就连那最坚韧而又狂乱的爱情，<br>
              归根结底也不过是转瞬即逝的现实，<br>
              唯有孤独永恒。<br>
              </p>
              <p style="text-align: right;">——加西亚·马尔克斯</p>
          </span> 
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-hbase-start" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/23/hbase-start/"
    >hbase 基础概念</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/23/hbase-start/" class="article-date">
  <time datetime="2020-02-23T07:30:38.000Z" itemprop="datePublished">2020-02-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.7k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">20分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a><table><tr><font color="#009100">导读</font></tr></table></h1><ol>
<li>HBase 是什么？有什么特性？</li>
<li>HBase 有什么优势？</li>
<li>HBase 使用哪些应用场景？</li>
<li>HBase 有哪些组件，分别具有什么功能？</li>
<li>HBase Region 如何进行分区及定位？</li>
<li>HBase 数据读写流程？</li>
<li>HBase WAL 机制是什么？</li>
<li>HBase 是如何管理 Region 的？</li>
</ol>
<h1 id="NoSQL-HBase"><a href="#NoSQL-HBase" class="headerlink" title="NoSQL-HBase"></a><table><tr><font color="#009100">NoSQL-HBase</font></tr></table></h1><p>HBase 是一个开源的、分布式的、版本化的非关系型数据库，它利用 Hadoop 分布式文件系统（Hadoop Distributed File System，HDFS）提供分布式数据存储。可以进行随机访问的存取和检索数据的存储平台，存储结构化和半结构化的数据.</p>
<p>HBase 特性：</p>
<ul>
<li>单条记录强一致性读写。</li>
<li>自动分片。</li>
<li>RegionServer 自动故障转移。</li>
<li>Hadoop/HDFS 整合。</li>
<li>支持 MapReduce。</li>
<li>支持 Java API。</li>
<li>支持 Thrift/REST API。</li>
<li>Block Cache 和 Bloom Filters 性能查询优化。</li>
<li>基于网页的操作管理。</li>
</ul>
<p>更多信息：<br><a href="https://hbase.apache.org/book.html#arch.overview.nosql" target="_blank" rel="noopener">https://hbase.apache.org/book.html#arch.overview.nosql</a></p>
<h1 id="HBase-优势"><a href="#HBase-优势" class="headerlink" title="HBase 优势"></a><table><tr><font color="#009100">HBase 优势</font></tr></table></h1><h2 id="容量巨大"><a href="#容量巨大" class="headerlink" title="容量巨大"></a>容量巨大</h2><p>HBase 单表支持百亿行、百万列数据，可横向和纵向两个维度插入数据，弹性好。在限定某个列的情况下，对单个表存储百亿甚至更多的数据没有性能问题。</p>
<p>HBase 采用 LSM 树作为内部数据存储结构，这种结构会周期性地将较小文件合并成大文件，以减少对磁盘的访问。  </p>
<p>LSM的原理：将对数据的修改增量保存在内存中，达到指定大小限制之后批量把数据flush到磁盘中，磁盘中树定期可以做merge操作，合并成一棵大树，以优化读性能。不过读取的时候稍微麻烦一些，读取时看这些数据在内存中，如果未能命中内存，则需要访问较多的磁盘文件。</p>
<p>更多关于LSM-tree：<br><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf" target="_blank" rel="noopener">https://www.cs.umb.edu/~poneil/lsmtree.pdf</a><br><a href="https://www.researchgate.net/publication/226763355_The_log-structured_merge-tree_LSM-tree" target="_blank" rel="noopener">https://www.researchgate.net/publication/226763355_The_log-structured_merge-tree_LSM-tree</a></p>
<h2 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h2><p>HBase 是面向列的存储和权限控制的，它里面的每个列是单独存储的，且支持基于列的独立检索。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191114/6-191114094154Q0.gif" alt></p>
<p>行存储里的一张表的数据都放在一起，但在列存储里是按照列分开保存的。<br>数据的插入和更新操作时，行存储会相对容易。<br>查询操作时，行存储需要读取所有的数据，而列存储则只需要读取相关列，可以大幅降低系统 I/O 吞吐量。</p>
<h2 id="稀疏性"><a href="#稀疏性" class="headerlink" title="稀疏性"></a>稀疏性</h2><p>通常在传统的关系性数据库中，每一列的数据类型是事先定义好的，会占用固定的内存空间，在此情况下，属性值为空（NULL）的列也需要占用存储空间。</p>
<p>而在 HBase 中的数据都是以字符串形式存储的，为空的列并不占用存储空间，因此 HBase 的列存储解决了数据稀疏性的问题，在很大程度上节省了存储开销。所以 HBase 通常可以设计成稀疏矩阵，同时这种方式比较接近实际的应用场景。</p>
<h2 id="扩展性强"><a href="#扩展性强" class="headerlink" title="扩展性强"></a>扩展性强</h2><p>HBase 工作在 HDFS 之上，理所当然地支持分布式表，也继承了 HDFS 的可扩展性。<br>HBase 表根据 Region 大小进行分区，分别存在集群中不同的节点上，当添加新的节点时，集群就重新调整，在新的节点启动 HBase 服务器，动态地实现扩展。</p>
<p>更多关于HDFS：<br><a href="http://c.biancheng.net/view/6502.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6502.html</a></p>
<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>HBase 运行在 HDFS 上，HDFS 的多副本存储可以让它在岀现故障时自动恢复，同时 HBase 内部也提供 WAL 和 Replication 机制。</p>
<p>WAL（Write-Ahead-Log）预写日志是在 HBase 服务器处理数据插入和删除的过程中用来记录操作内容的日志，保证了数据写入时不会因集群异常而导致写入数据的丢失；而 Replication 机制是基于日志操作来做数据同步的。</p>
<p>当集群中单个节点出现故障时，协调服务组件 ZooKeeper 通知集群的主节点，将故障节点的 HLog 中的日志信息分发到各从节点进行数据恢复</p>
<h1 id="HBase-使用场景"><a href="#HBase-使用场景" class="headerlink" title="HBase 使用场景"></a><table><tr><font color="#009100">HBase 使用场景</font></tr></table></h1><p>HBase 解决不了所有的问题，但是针对某些特点的数据可以使用 HBase 高效地解决，如以下的应用场景。</p>
<ol>
<li>数据模式是动态的或者可变的，且支持半结构化和非结构化的数据。</li>
<li>数据库中的很多列都包含了很多空字段，在 HBase 中的空字段不会像在关系型数据库中占用空间。</li>
<li>需要很高的吞吐量，瞬间写入量很大。</li>
<li>数据有很多版本需要维护，HBase 利用时间戳来区分不同版本的数据。</li>
<li>具有高可扩展性，能动态地扩展整个存储系统。</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>Facebook 公司的 Social Inbox 系统，使用 HBase 作为消息服务的基础存储设施，每月可处理几千亿条的消息；</li>
<li>Yahoo 公司使用 HBase 存储检查近似重复的指纹信息的文档，它的集群当中分别运行着 Hadoop 和 HBase，表中存了上百万行数据；</li>
<li>Adobe 公司使用 Hadoop+HBase 的生产集群，将数据直接持续地存储在 HBase 中，并将 HBase 作为数据源进行 MapReduce 的作业处理；</li>
<li>Apache 公司使用 HBase 来维护 Wiki 的相关信息。</li>
</ul>
<p>更多案例：<br><a href="http://c.biancheng.net/view/6514.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6514.html</a></p>
<h1 id="HBase的组件和功能"><a href="#HBase的组件和功能" class="headerlink" title="HBase的组件和功能"></a><table><tr><font color="#009100">HBase的组件和功能</font></tr></table></h1><p>HBase 各个组件：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191114/6-191114125630422.gif" alt></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>整个 HBase 系统的入口，使用 HBase RPC 机制于 HMaster 和 RegionServer 进行通信。  </p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>ZooKeeper 是一个高性能、集中化、分布式应用程序协调服务。  </p>
<p>协调任务如下： </p>
<ol>
<li>Master 选举</li>
<li>系统容错（协同HMaster管理RegionServer）</li>
<li>Region 元数据管理  </li>
</ol>
<blockquote>
<p>Region 元数据（Meta表）存储在 Zookeeper 中，客户端发起新的查询请求需要查询Meta表获取 Region 位置。  </p>
</blockquote>
<ol start="4">
<li>Region 状态管理</li>
</ol>
<blockquote>
<p>HBase 集群中 Region 会经常发生变更，其原因可能是系统故障，配置修改，或者是 Region 的分裂和合并。只要 Region 发生变化，就需要让集群的所有节点知晓，否则就会出现某些事务性的异常。</p>
</blockquote>
<ol start="5">
<li>提供 Meta 表存储位置</li>
</ol>
<blockquote>
<p>在 HBase 集群中，数据库表信息、列族信息及列族存储位置信息都属于元数据。这些元数据存储在 Meta 表中，而 Meta 表的位置入口由 ZooKeeper 来提供。</p>
</blockquote>
<h2 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h2><p>HMaster 是 HBase 集群中的主服务器，负责监控集群中的所有 RegionServer，并且是所有元数据更改的接口。</p>
<p>在分布式集群中，HMaster 服务器通常运行在 HDFS 的 NameNode上，HMaster 通过 ZooKeeper 来避免单点故障，在集群中可以启动多个 HMaster，但 ZooKeeper 的选举机制能够保证同时只有一个 HMaster 处于 Active 状态，其他的 HMaster 处于热备份状态。</p>
<p>HMaster 主要负责表和 Region 的管理工作。</p>
<ol>
<li>管理用户对表的增、删、改、查操作。</li>
<li>管理 RegionServer 的负载均衡，调整 Region 的分布。</li>
<li>Region 的分配和移除。</li>
<li>处理 RegionServer 的故障转移。</li>
</ol>
<h2 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h2><p>RegionServer 主要负责响应用户的请求，向 HDFS 读写数据。一般在分布式集群中，RegionServer 运行在 DataNode 服务器上，实现数据的本地性。</p>
<blockquote>
<p>RegionServer 是 HBase 中最核心的模块，其内部管理了一系列 Region 对象，每个 Region 由多个 HStore 组成，每个 HStore 对应表中一个列族的存储。</p>
</blockquote>
<p>每个 RegionServer 包含多个 Region，它负责的功能如下:</p>
<ol>
<li>处理分批给它的 Region。</li>
<li>处理客户端读写请求。</li>
<li>刷新缓存到 HDFS 中。</li>
<li>处理 Region 分片。</li>
<li>执行压缩。</li>
</ol>
<h1 id="HBase-Region分区及定位"><a href="#HBase-Region分区及定位" class="headerlink" title="HBase Region分区及定位"></a><table><tr><font color="#009100">HBase Region分区及定位</font></tr></table></h1><p>在 HBase 中，表的所有行都是按照 RowKey 的字典序排列的，表在行的方向上分割为多个分区（Region）。<br><img src="http://c.biancheng.net/uploads/allimg/191115/6-191115164IK02.gif" alt><br>每张表一开始只有一个 Region，但是随着数据的插入，HBase 会根据一定的规则将表进行水平拆分，形成两个 Region。当表中的行越来越多时，就会产生越来越多的 Region，而这些 Region 无法存储到一台机器上时，则可将其分布存储到多台机器上。</p>
<p>Master 主服务器把不同的 Region 分配到不同的 Region 服务器上，同一个行键的 Region 不会被拆分到多个 Region 服务器上。每个 Region 服务器负责管理一个 Region，通常在每个 Region 服务器上会放置 10 ~ 1000 个 Region，HBase中Region 的物理存储如下图所示。<br><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151649162H.gif" alt><br>客户端在插入、删除、查询数据时需要知道哪个 Region 服务器上存储所需的数据，这个查找 Region 的过程称为 Region 定位。<br>HBase 中的每个 Region 由三个要素组成，包括 Region 所属的表、第一行和最后一行。其中，第一个 Region 没有首行，最后一个 Region 没有末行。每个 Region 都有一个 RegionlD 来标识它的唯一性，Region 标识符就可以表示成“表名+开始行键+RegionID”。</p>
<h2 id="Meta-表"><a href="#Meta-表" class="headerlink" title="Meta 表"></a>Meta 表</h2><p>Meta 表的每个条目包含两项内容，一项是 Region 标识符，另一项是 Region 服务器标识。这个条目就表示 Region 和 Region 服务器之间的对应关系，从而就可以使用户知道某个 Region 存储在哪个 Region 服务器中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> scan <span class="string">'hbase:meta'</span></span></span><br><span class="line">ROW                                                  COLUMN+CELL                                                                                                                                        </span><br><span class="line">hbase:namespace,,1582440367299.c349a23aa3536a0c26e9 column=info:regioninfo, timestamp=1593651118107, value=&#123;ENCODED =&gt; c349a23aa3536a0c26e96e5f4201c03c, NAME =&gt; 'hbase:namespace,,1582440367299.c349a23aa36e5f4201c03c.536a0c26e96e5f4201c03c.', STARTKEY =&gt; '', ENDKEY =&gt; ''&#125;</span><br></pre></td></tr></table></figure>

<p>Meta 表里有一个列族 info。info 包含了三个列，分别为 RegioninfoServer 和 Serverstartcode。Regionlnfo中记录了 Region 的详细信息，包括行键范围 StartKey 和 EndKey、列族列表和属性。</p>
<h2 id="Region-定位"><a href="#Region-定位" class="headerlink" title="Region 定位"></a>Region 定位</h2><p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151AI1V8.gif" alt></p>
<p>Hbase 二层架构的 Region 定位流程：</p>
<ol>
<li>找 Meta 表位置信息<blockquote>
<p>通过 ZooKeeper 中的 /hbase/meta-region-server 先找到 Meta 表所在的 Region 服务器信息，从中获取分区 Meta 表位置。</p>
</blockquote>
</li>
<li>根据 Meta 表位置信息定位 Region，找出 Region 所在的 Region 服务器。 </li>
<li>通过 Mate 表得到所需的表和行键所在的 Region 信息，然后从 Region 服务器上找到所需的数据。</li>
</ol>
<p>详细信息：<br><a href="http://c.biancheng.net/view/6528.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6528.html</a></p>
<h1 id="HBase-数据的读写流程"><a href="#HBase-数据的读写流程" class="headerlink" title="HBase 数据的读写流程"></a><table><tr><font color="#009100">HBase 数据的读写流程</font></tr></table></h1><p>HBase 的核心模块是 Region 服务器。Region 服务器由多个 Region 块构成，Region 块中存储一系列连续的数据集。Region 服务器主要构成部分是 HLog 和 Region 块。HLog 记录该 Region 的操作日志。</p>
<p>Region 对象由多个 Store 组成，每个 Store 对应当前分区中的一个列族，每个 Store 管理一块内存。当 MemStore 中的数据达到一定条件时会写入 StoreFile 文件中，因此每个 Store 包含若干个 StoreFile 文件。StoreFile 文件对应 HDFS 中的 HFile 文件。</p>
<p>HBase 群集数据的构成如图所示。<br><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151FG1X5.gif" alt></p>
<h2 id="MemStore"><a href="#MemStore" class="headerlink" title="MemStore"></a>MemStore</h2><p>当 Region 服务器收到写请求的时候，Region 服务器会将请求转至相应的 Region。数据先被写入 MemStore，当到达一定的阈值时，MemStore 中的数据会被刷新到 HFile 中进行持久化存储。</p>
<p>HBase 将最近接收到的数据缓存在 MemStore 中，在持久化到 HDFS 之前完成排序，再顺序写入 HDFS，为后续数据的检索进行优化。因为 MemStore 缓存的是最近增加的数据，所以也提高了对近期数据的操作速度。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>Store 是 Region 服务器的核心，存储的是同一个列族下的数据，每个 Store 包含一块 MemStore 和 StoreFile（ 0 个或多个）。StoreFile 是 HBase 中最小的数据存储单元。</p>
<p>数据写入 MemStore 缓存，当 MemStore 缓存满时，内存中的数据会持久化到磁盘中一个 StoreFile 文件中，随着 StoreFile 文件数量的不断增加，数量达到一个阈值后，就会促使文件合并成一个大的 StoreFile 文件。</p>
<p>由于 StoreFile 文件的不断合并，造成 StoreFile 文件的大小超过一定的阈值，因此，会促使文件进行分裂操作。同时，当前的一个父 Region 会被分成两个子 Region, 父 Region 会下线，新分裂出的两个子 Region 会被 Master 分配到相应的 Regio n服务器上。</p>
<p>Store 的合并和分裂过程如下图所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151G132A4.gif" alt></p>
<h2 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h2><p>将 MemStore 内存中的数据写入 StoreFile 文件中，StoreFile 底层是以 HFile 格式保存的。</p>
<p>HFile 的存储格式如下图所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151G225A3.gif" alt></p>
<p>HFile 文件是不定长的，长度固定的只有其中的两块：Trailer 和 File Info。Trailer 中有指针指向其他数据块的起始点，File Info 记录了文件的一些 Meta 信息。每个 Data 块的大小可以在创建一个 Table 的时候通过参数指定（默认块大小为 64KB）。每个 Data 块除了开头的 Magic 以外就是由一个键值对拼接而成的，Magic 内容是一些随机数字，用于防止数据损坏。</p>
<p>HFile 里面的每个键值对就是一个简单的 Byte 数组。但是这个 Byte 数组里面包含了很多项， 并且有固定的结构，其具体结构如图所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151G400W1.gif" alt></p>
<p>键值对结构以两个固定长度的数值开始，分别表示 Key 的长度和 Value 的长度。紧接着是 Key，Key 以 RowLength 开始，是固定长度的数值，表示 RowKey 的长度；接着是 Row，然后是固定长度的数值 ColumnFamilyLength，表示 Family 的长度；之后是 Family 列族，接着是 Qualifier 列标识符，Key 最后以两个固定长度的数值 Time Stamp 和 Key Type(Put/Delete) 结束。Value部分没有这么复杂的结构，就是纯粹的二进制数据。</p>
<h2 id="HBase-数据写入流程"><a href="#HBase-数据写入流程" class="headerlink" title="HBase 数据写入流程"></a>HBase 数据写入流程</h2><p>1) 客户端访问 ZooKeeper，从 Meta 表得到写入数据对应的 Region 信息和相应 的Region 服务器。</p>
<p>2) 客户端访问相应的 Region 服务器，把数据分别写入 HLog 和 MemStore。MemStore 数据容量有限，当达到一个阈值后，则把数据写入磁盘文件 StoreFile 中，在 HLog 文件中写入一个标记，表示 MemStore 缓存中的数据已被写入 StoreFile 中。如果 MemStore 中的数据丢失，则可以从 HLog 上恢复。</p>
<p>3) 当多个 StoreFile 文件达到阈值后，会触发 Store.compact() 将多个 StoreFile 文件合并为一个 大文件。</p>
<h2 id="HBase-数据读取流程"><a href="#HBase-数据读取流程" class="headerlink" title="HBase 数据读取流程"></a>HBase 数据读取流程</h2><p>1) 客户端先访问 ZooKeeper，从 Meta 表读取 Region 信息对应的服务器。</p>
<p>2) 客户端向对应 Region 服务器发送读取数据的请求，Region 接收请求后，先从 MemStore 查找数据；如果没有，再到 StoreFile 上读取，然后将数据返回给客户端。<br><img src="https://hbase.apache.org/images/offheap-overview.png" alt></p>
<h1 id="HBase-WAL机制"><a href="#HBase-WAL机制" class="headerlink" title="HBase WAL机制"></a><table><tr><font color="#009100">HBase WAL机制</font></tr></table></h1><p>Region服务器发生故障时， MemStore 缓存中还没有被写入文件的数据会全部丢失。因此，HBase 采用 HLog 来保证系统发生故障时能够恢复到正常的状态。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151I13B93.gif" alt></p>
<p>每个 Region 服务器都有一个 HLog 文件，同一个 Region 服务器的 Region 对象共用一个 HLog，HLog 是一种预写日志（Write Ahead Log）文件。</p>
<p>预写日志文件（WAL）保存在 HDFS 上，目录：/hbase/WALs/ , 每个子目录对应一个 Region 。</p>
<p>用户更新数据必须先被记入日志后才能写入 MemStore 缓存，当缓存内容对应的日志已经被写入磁盘后，即日志写成功后，缓存的内容才会被写入磁盘。</p>
<p>ZooKeeper 会实时监测每个 Region 服务器的状态，当某个 Region 服务器发生故障时，ZooKeeper 会通知 Master，Master 首先会处理该故障 Region 服务器上遗留的 HLog 文件。</p>
<p>系统会根据每条日志记录所属的 Region 对象对 HLog 数据进行拆分，并分别存放到相应 Region 对象的目录下。再将失效的 Region 重新分配到可用的 Region 服务器中，并在可用的 Region 服务器中重新进行日志记录中的各种操作， 把日志记录中的数据写入 MemStore 然后刷新到磁盘的 StoreFile 文件中，完成数据恢复。</p>
<p>Region 对象共用一个 HLog 的方式中，多个 Region 对象在进行更新操作需要修改日志时，只需要不断地把日志记录追加到单个日志文件中，而不需要同时打开、写入多个日志文件中，因此可以减少磁盘寻址次数，提高对表的写操作性能。</p>
<p><a href="https://hbase.apache.org/book.html#wal" target="_blank" rel="noopener">https://hbase.apache.org/book.html#wal</a><br><a href="http://c.biancheng.net/view/6533.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6533.html</a></p>
<h1 id="HBase-Region管理"><a href="#HBase-Region管理" class="headerlink" title="HBase Region管理"></a><table><tr><font color="#009100">HBase Region管理</font></tr></table></h1><p>Region 是 HBase 集群的负载均衡和数据分发的基本单元。当 HBase中 表的容量非常庞大时，用户就需要将表中的内容分布到多台机器上。那么，需要根据行键的值对表中的行进行划分，每个行区间构成一个 Region，一个 Region 包含了位于某个阈值区间的所有数据。</p>
<h2 id="HFile-合并"><a href="#HFile-合并" class="headerlink" title="HFile 合并"></a>HFile 合并</h2><p>每个 RegionServer 包含多个 Region，而每个 Region 又对应多个 Store，每一个 Store 对应表中一个列族的存储，且每个 Store 由一个 MemStore 和多个 StoreFile 文件组成。</p>
<p>StoreFile 在底层文件系统中由 HFile 实现，也可以把 Store 看作由一个 MemStore 和多个 HFile 文件组成。MemStore 充当内存写缓存，默认大小 64MB，当 MemStore 超过阈值时，MemStore 中的数据会刷新到一个新的 HFile 文件中来持久化存储。</p>
<p>久而久之，每个 Store 中的 HFile 文件会越来越多，I/O 操作的速度也随之变慢，读写也会延时，导致慢操作。因此，需要对 HFile 文件进行合并，让文件更紧凑，让系统更有效率。</p>
<p>HFile 的合并分为两种类型，分别是 Minor 合并和 Major 合并。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191115/6-1911151KF3V3.gif" alt></p>
<h3 id="Minor-合并"><a href="#Minor-合并" class="headerlink" title="Minor 合并"></a>Minor 合并</h3><p>Minor 合并是把多个小 HFile 合并生成一个大的 HFile。<br>执行合并时，HBase 读出已有的多个 HFile 的内容，把记录写入一个新文件中。然后把新文件设置为激活状态，并标记旧文件为删除。</p>
<h3 id="Major-合并"><a href="#Major-合并" class="headerlink" title="Major 合并"></a>Major 合并</h3><p>Major 合并针对的是给定 Region 的一个列族的所有 HFile，将 Store 中的所有 HFile 合并成一个大文件，有时也会对整个表的同一列族的 HFile 进行合并，这是一个耗时和耗费资源的操作，会影响集群性能。</p>
<h2 id="Region-拆分"><a href="#Region-拆分" class="headerlink" title="Region 拆分"></a>Region 拆分</h2><p>Region 拆分是 HBase 能够拥有良好扩展性的最重要因素。一旦 Region 的负载过大或者超过阈值时，它就会被分裂成两个新的 Region.</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191118/6-19111P9141D39.gif" alt></p>
<p>这个过程是由 RegionServer 完成的，其拆分流程如下。</p>
<ol>
<li>将需要拆分的 Region下线，阻止所有对该 Region 的客户端请求，Master 会检测到 Region 的状态为 SPLITTING。</li>
<li>将一个 Region 拆分成两个子 Region，先在父 Region下建立两个引用文件，分别指向 Region 的首行和末行，这时两个引用文件并不会从父 Region 中复制数据。</li>
<li>之后在 HDFS 上建立两个子 Region 的目录，分别复制上一步建立的引用文件，每个子 Region 分别占父 Region 的一半数据。复制登录完成后删除两个引用文件。</li>
<li>完成子 Region 创建后，向 Meta 表发送新产生的 Region 的元数据信息。</li>
<li>将 Region 的拆分信息更新到 HMaster，并且每个 Region 进入可用状态。</li>
</ol>
<p>拆分策略：</p>
<ol>
<li>ConstantSizeRegionSplitPolicy</li>
<li>IncreasingToUpperBoundRegionSplitPolicy</li>
<li>SteppingSplitPolicy</li>
<li>DisabledRegionSplitPolicy</li>
</ol>
<h2 id="Region-合并"><a href="#Region-合并" class="headerlink" title="Region 合并"></a>Region 合并</h2><p>从 Region 的拆分过程中可以看到，随着表的增大，Region 的数量也越来越大。如果有很多 Region，它们中 MemStore 也过多，会频繁出现数据从内存被刷新到 HFile 的操作，从而会对用户请求产生较大的影响，可能阻塞该 Region 服务器上的更新操作。过多的 Region 会增加 ZooKeeper 的负担。</p>
<p>因此，当 Region 服务器中的 Region 数量到达阈值时，Region 服务器就会发起 Region 合并，其合并过程如下。</p>
<ol>
<li>客户端发起 Region 合并处理，并发送 Region 合并请求给 Master。</li>
<li>Master 在 Region 服务器上把 Region 移到一起，并发起一个 Region 合并操作的请求。</li>
<li>Region 服务器将准备合并的 Region下线，然后进行合并。</li>
<li>从 Meta 表删除被合并的 Region 元数据，新的合并了的 Region 的元数据被更新写入 Meta 表中。</li>
<li>合并的 Region 被设置为上线状态并接受访问，同时更新 Region 信息到 Master。</li>
</ol>
<h2 id="Region-负载均衡"><a href="#Region-负载均衡" class="headerlink" title="Region 负载均衡"></a>Region 负载均衡</h2><p>Region 的负载均衡由 Master 来完成，Master 有一个内置的负载均衡器，在默认情况下，均衡器每 5 分钟运行一次，用户可以配置。负载均衡操作分为两步进行：首先生成负载均衡计划表， 然后按照计划表执行 Region 的分配。</p>
<p>执行负载均衡前要明确，在以下几种情况时，Master 是不会执行负载均衡的。</p>
<ul>
<li>均衡负载开关关闭。</li>
<li>Master 没有初始化。</li>
<li>当前有 Region 处于拆分状态。</li>
<li>当前集群中有 Region 服务器出现故障。</li>
</ul>
<p>Master 内部使用一套集群负载评分的算法，来评估 HBase 某一个表的 Region 是否需要进行重新分配。这套算法分别从 Region 服务器中 Region 的数目、表的 Region 数、MenStore 大小、 StoreFile 大小、数据本地性等几个维度来对集群进行评分，评分越低代表集群的负载越合理。</p>
<p>负载均衡策略：  </p>
<ol>
<li>RandomRegionPicker</li>
<li>LoadPicker</li>
<li>LocalityBasedPicker</li>
</ol>
<p><a href="http://c.biancheng.net/view/6539.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6539.html</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><table><tr><font color="#009100">总结</font></tr></table></h1><ol>
<li>HBase 是分布式的非关系型数据库，支持多版本数据存储。容量大，支持百亿行，百万列的数据存储。</li>
<li>HBase 不支持事务，但是支持单条数据强一致性的读写。</li>
<li>HBase 中，表的所有行都是按照 RowKey 的字典序排列的，表在行的方向上分割为多个分区（Region）。</li>
<li>HBase 自动分片技术是通过 Region 的自动拆分、合并实现的，数据的读写都需要定位对应的 Region。</li>
<li>HBase 通过预写日志 WAL (Write Ahead Log) 保证 Region 故障恢复，Region 共用一个 HLog 文件。</li>
<li>HBase 底层是基于 LSM-tree 实现，所以 HBase 的写过程是先写 HLog 和 MemStore，再刷新到磁盘。读过程是先查询 Memtore 是否存在，不存在再检索磁盘。</li>
<li>LSM-tree 使得 HBase 实现了批量数据写入磁盘，大大提高数据写入性能。但是数据存储被拆分成了两个部分，一部分保存在磁盘、另一部分缓存在内存，不得不牺牲一部分读性能。</li>
<li>为了提升查询效率，HBase 使用了 BloomFilter 缩减查询范围，同时对 storefile 进行合并，减少磁盘寻址次数。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><table><tr><font color="#009100">参考文档</font></tr></table></h1><p><a href="https://hbase.apache.org/book.html#regionserver.offheap.overview" target="_blank" rel="noopener">https://hbase.apache.org/book.html#regionserver.offheap.overview</a><br><a href="http://c.biancheng.net/view/6499.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6499.html</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hbase/" rel="tag">hbase</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/11/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Andrew
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        <!-- 
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
         -->
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Andrew 的笔记"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>